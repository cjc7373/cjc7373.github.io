<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Coherence's Blog</title><link>https://blog.coherence.codes/</link><description>Recent content on Coherence's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</copyright><lastBuildDate>Sun, 10 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.coherence.codes/index.xml" rel="self" type="application/rss+xml"/><item><title>记一次 mpv 异常关闭的调试</title><link>https://blog.coherence.codes/posts/2023/mpv_debug/</link><pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/mpv_debug/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/mpv_debug/ -&lt;h2 id="查不出的问题">查不出的问题&lt;/h2>
&lt;p>长久以来我都被 mpv 的一个问题所困扰，那就是在正常播放视频时 mpv 有概率会自动退出（通常是按下暂停键的时候）。通过 &lt;code>-v -v -v&lt;/code> 参数查看详细日志发现 mpv 接收到了 stop 命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>cplayer&lt;span style="color:#f92672">]&lt;/span> Run command: stop, flags&lt;span style="color:#f92672">=&lt;/span>64, args&lt;span style="color:#f92672">=[&lt;/span>flags&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是这个命令是谁发的不得而知。一开始怀疑是插件的问题，然而禁用所有插件（&lt;code>~/.config/mpv/scripts&lt;/code> 目录）后问题依旧。后尝试用 &lt;code>--no-config&lt;/code> 参数禁用所有配置，发现问题消失，于是尝试注释掉所有 &lt;code>mpv.conf&lt;/code> 中的配置，发现问题依旧。我还怀疑过是 &lt;code>pipewire&lt;/code>/&lt;code>xorg&lt;/code> 的问题，但是并没有搜索到相关信息。&lt;/p>
&lt;p>我还观察到 vlc 是不是也会出现播放时自动停止的现象，另外 youtube/bilibili 播放视频时会经常自动跳转到开头。后来证实这其实都是同一个问题导致的..&lt;/p>
&lt;h2 id="线索">线索&lt;/h2>
&lt;p>在 mpv 的 issue 中找到了一个问题相同的 &lt;a href="https://github.com/mpv-player/mpv/issues/11988">bug report&lt;/a>，开发者认为这是插件导致的，但是我已经禁用所有插件了，于是我留言询问应该如何排查，有一个人指出了可能和 &lt;code>mpv-mpris&lt;/code> 有关。&lt;/p>
&lt;p>&lt;a href="https://wiki.archlinux.org/title/MPRIS">MPRIS&lt;/a> 是一个 dbus 接口，提供了控制媒体播放器的相应 API，绝大多数应用，包括上述提到的几个，都支持这一接口。mpv 的 mpris 支持通过 &lt;code>mpv-mpris&lt;/code> 包提供。看到这个名字我恍然大悟，&lt;code>mpv-mpris&lt;/code> 由系统包管理器安装，因此并没有出现在用户的插件目录下。当即我查看了 &lt;code>mpv-mpris&lt;/code> 的源码，发现其为 mpv C 拓展，而不是常见的 Lua 拓展。&lt;/p>
&lt;p>从&lt;a href="https://github.com/hoyon/mpv-mpris/blob/16fee38988bb0f4a0865b6e8c3b332df2d6d8f14/mpris.c#L602C26-L602C26">这里&lt;/a>可以看到，它在收到 mpris 的 &lt;code>Stop()&lt;/code> 方法后，会向 mpv 发送 stop 命令，因此我准备加一行日志看看到底是不是 &lt;code>mpv-mpris&lt;/code> 导致了上述问题。询问了 ChatGPT 之后发现其对于如何在 mpv C 扩展中打印日志完全是在瞎扯.. 后来发现直接用 &lt;code>printf&lt;/code> 就行.. 从函数签名可以看到其包含了 sender 的信息，于是将其打印。这里我并没有 clone 仓库进行构建，而是直接复制 archlinux 中的 PKGBUILD，先用 &lt;code>makepkg -o&lt;/code> 下载解压源码，修改后再用 &lt;code>makepkg -e&lt;/code> 进行构建，这样做的好处是无需关心具体的构建流程以及如何应用构建后的插件，build 完直接装就行。&lt;/p>
&lt;p>在复现问题之后发现果然是 &lt;code>mpv-mpris&lt;/code> 调用了 stop 命令，日志为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mpris: sender: :1.41, _object_path: /org/mpris/MediaPlayer2, interface_name: org.mpris.MediaPlayer2.Player, method_name: Stop, parameters: &lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>继续询问 ChatGPT 如何从 &lt;code>:1.41&lt;/code> 这个标识符得到发送者的进程，这次它倒没有瞎扯，告诉我 dbus 包含一个内省方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ dbus-send --session --dest&lt;span style="color:#f92672">=&lt;/span>org.freedesktop.DBus --type&lt;span style="color:#f92672">=&lt;/span>method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.GetConnectionUnixProcessID string:&lt;span style="color:#e6db74">&amp;#34;:1.41&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>method &lt;span style="color:#66d9ef">return&lt;/span> time&lt;span style="color:#f92672">=&lt;/span>1702192468.323155 sender&lt;span style="color:#f92672">=&lt;/span>org.freedesktop.DBus -&amp;gt; destination&lt;span style="color:#f92672">=&lt;/span>:1.2850 serial&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> reply_serial&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uint32 &lt;span style="color:#ae81ff">1688&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再用 ps 等命令查看，发现该进程为 kdeconnect。直接上 bugs.kde.org 搜索得到一个类似的 &lt;a href="https://bugs.kde.org/show_bug.cgi?id=476123">bug report&lt;/a>，不过除了作者没有人回应。&lt;/p>
&lt;p>翻找源码发现大概是在 &lt;a href="https://invent.kde.org/network/kdeconnect-kde/-/blob/master/plugins/mpriscontrol/mpriscontrolplugin.cpp#L284">mpriscontrolplugin.cpp#L284&lt;/a> 调用的 mpris Stop 方法，去掉注释重新编译后查看日志发现如下条目：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>kdeconnect.core: TCP connection done (i&amp;#39;m the existing device)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.core: Starting server ssl (I&amp;#39;m the client TCP socket)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.core: Socket successfully established an SSL connection
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.core: It is a known device &amp;#34;xxxx&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.plugin.mpris: Calling action &amp;#34;Stop&amp;#34; in &amp;#34;org.mpris.MediaPlayer2.mpv&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.plugin.notification: Not found noti by internal Id: &amp;#34;0|org.kde.kdeconnect_tp|-1850276765|null|10264&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.plugin.mpris: MPRIS service &amp;#34;org.mpris.MediaPlayer2.mpv&amp;#34; just went offline
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.plugin.mpris: Mpris removePlayer &amp;#34;org.mpris.MediaPlayer2.mpv&amp;#34; -&amp;gt; &amp;#34;mpv&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基本能够确认是从这里进行调用的了。根据函数推断该函数是处理配对的其他设备发送的请求，出问题时我配对的设备只有我的安卓手机，所以问题应该出在安卓端。看了眼 kdeconnect-android 的源码，看不懂啊&amp;hellip; 本次 debug 到此结束。&lt;/p>
&lt;p>由于 vlc/chromium 同样实现 mpris 接口，所以上面观察到的现象基本可以确认也是 kdeconnect 导致的了。&lt;/p>
&lt;h2 id="怎么办呢">怎么办呢？&lt;/h2>
&lt;p>目前的 workaround 是关闭 KDE Connect 中的 Multimedia control receiver 插件，drawback 是其他设备无法再控制本机的媒体播放器了，不过我也不怎么用，问题不大。&lt;/p>
- https://blog.coherence.codes/posts/2023/mpv_debug/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>MIT 6.824 学习笔记(二) Raft</title><link>https://blog.coherence.codes/posts/2023/mit_6.824_2_raft/</link><pubDate>Sun, 01 Oct 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/mit_6.824_2_raft/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/mit_6.824_2_raft/ -&lt;blockquote>
&lt;p>Note: 为了保持准确性，我会尽量使用英文术语。&lt;/p>
&lt;/blockquote>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>在过去十年, Leslie Lamport 的 Paxos 几乎成了共识的同义词.. Paxos 首先定义了一种协议来对单个决定达成共识, 比如一条单个的 log entry, 这被称为 single-decree Paxos. 其支持多个决定的版本 (比如 log) 被称为 muti-Paxos。然而，Paxos 的缺点是难以理解，并且没有提供一个良好的基础来构建可行的实现。&lt;/p>
&lt;p>相较于 Paxos，Raft 的目标是易于理解且符合直觉。为了使 Raft 易于理解，作者采取了解耦 (Raft 将共识问题分解成几个子问题 leader election, log replication, safety, and membership changes) 和缩减状态空间的方式。&lt;/p>
&lt;p>Raft 和已有的共识算法类似（尤其是 Viewstamped Replication），但它有一些新特性。Raft 采取了强 leader 的设计，例如 log entry 只会从 leader 向其他节点分发。这可能是为了性能考虑（比无 leader 要更快，RPC 也更少）Raft 采用基于随机计时器的 leader 选举, 从而用一种简单的方法来解决冲突。另外还有处理成员变更方面的改进。&lt;/p>
&lt;p>为了解决单点故障问题，Raft 采用了 Majority Vote，基本上任何操作都需要得到多数确认才能够执行。为了避免 tie，Raft 的节点数量必须为奇数。因此在一个 2f+1 个节点的系统中，最多允许 f 个节点故障，f+1 即为法定人数（quorum）。&lt;/p>
&lt;p>如果 server 不出错，网络也很稳定，共识算法是很简单的，比如在 Raft 中，leader 被选举出来，client 的请求由 leader 处理并转发给 followers，所有 server 都和 leader 保持一致，这个过程是很简单并且直观的。这些算法真正处理的、细节繁杂的地方是 server 出错、RPC 受网络影响（包括包的延迟，重复，顺序改变，丢失，网络分区）的时候。&lt;/p>
&lt;h2 id="replicated-state-machines-复制状态机">Replicated state machines (复制状态机)&lt;/h2>
&lt;p>通常实现主从复制有两种方法：&lt;/p>
&lt;ul>
&lt;li>状态转移（State trasnsfer），主服务器将存储的所有状态都发送给从服务器&lt;/li>
&lt;li>复制状态机（Replicated State Machine），将服务器视为确定性的状态机，主服务器将所有输入发送给从服务器，那么他们在任意时刻的状态都是相同的&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="./image-20230907175938021.png" alt="image-20230907175938021">&lt;/p>
&lt;p>Replicated state machines 通常使用 replicated log 实现. 每个节点存储一份 log (一系列指令), 其状态机按顺序执行它们. 每个状态机获得的 log 都是完全一致的, 所以它们是确定性的, 存储有完全相同的状态. Replicated log 的一致性由共识算法保证, 一个节点上的共识模块从 client 接收指令, 并把它们加到 log 中, 它和其他节点的共识模块通信以保证 log 存储了相同顺序的指令。在 Raft 中，状态机由上层应用负责处理。&lt;/p>
&lt;p>共识算法需要具有以下属性:&lt;/p>
&lt;ul>
&lt;li>在非拜占庭错误 (包括 network delays, partitions, and packet loss, duplication, and reordering) 下保证安全性 (safety), 即不会返回不正确的结果&lt;/li>
&lt;li>只要多数 (即超过一半) 节点工作, 服务就是可用的&lt;/li>
&lt;li>不依赖时间来确保一致性, 错误的时间或是极端情况下的延迟只会导致可用性问题&lt;/li>
&lt;li>只要多数节点回应, 一条命令就能够完成, 少数 slow servers 不会影响整个系统的性能&lt;/li>
&lt;/ul>
&lt;h2 id="raft-共识算法">Raft 共识算法&lt;/h2>
&lt;p>&lt;img src="./image-20230908182459520.png" alt="image-20230908182459520">&lt;/p>
&lt;p>这张图（论文中的 Figure 2）总结了 Raft 协议（除了成员变更和 log 压缩），我们在实现 Raft 协议时会反复看这张图。&lt;/p>
&lt;p>Raft 主要由两个 RPC 构成：&lt;/p>
&lt;ul>
&lt;li>&lt;code>RequestVote RPC&lt;/code>，由 candidate 请求，用于收集投票&lt;/li>
&lt;li>&lt;code>AppendEntries RPC&lt;/code>，由 leader 请求，用于心跳和复制 log entries&lt;/li>
&lt;/ul>
&lt;p>Raft 首先将选举一个 leader, leader 的存在能够简化对 replicated log 的管理，比如 leader 能够独自决定把新的 entry 放在哪里，数据自然地由 leader 流向其他 servers。leader 拥有完全管理 replicated log 的权力，leader 从 clients 接受 log entries, 分发给其他节点, 并告诉它们何时能应用这些 log entries 到它们自己的状态机。&lt;/p>
&lt;p>关键性质:&lt;/p>
&lt;ul>
&lt;li>Election Safety: 一个任期中只有一个 leader&lt;/li>
&lt;li>Leader Append-Only: leader 不会覆盖或删除自己的 log entry, 只会 append&lt;/li>
&lt;li>Log Matching: 如果两份 log 中某一个 entry 的 index 和 term 相同, 那么两份 log 从头开始直到该 entry 都是相同的&lt;/li>
&lt;li>Leader Completeness: 如果一个 log entry 在某一 term 中 commit 了, 这个 entry 会存在于任何更高任期的 leader 的 log 中&lt;/li>
&lt;li>State Machine Safety: 如果一个 server 将一个指定 index 的 log entry 应用到了 state machine 中（i.e. commit 了这个 entry）, 没有其他 server 会在那个 index 上会应用其他的 entry&lt;/li>
&lt;/ul>
&lt;p>这些性质看起来比较抽象，然而是保证 Raft 的安全性所必须的，下文会详细解释。&lt;/p>
&lt;h3 id="leader-选举">leader 选举&lt;/h3>
&lt;p>任何一个节点处于以下三种状态: leader, follower, candidate&lt;/p>
&lt;p>&lt;img src="./image-20230907175951530.png" alt="image-20230907175951530">&lt;/p>
&lt;p>上图描述了 server 所有的状态变化，下面描述几个关键的步骤：&lt;/p>
&lt;ul>
&lt;li>Follower -&amp;gt; Candidate：开始选举，follower 递增 term 并进入 candidate 状态，它接着给自己投票并向其他 server 发送 RequestVote RPC。每个 server 在一个 term 只能给一个 candidate 投票，基于先来先得的原则&lt;/li>
&lt;li>Candidate -&amp;gt; Leader：当 candidate 接收到了多数票（majority）之后将赢得选举，接着它会马上发送心跳包宣告自己的权威并阻止新的选举。leader 会一直保持 leader 状态，除非 a). 它 fail 了 b). 由于丢包等原因导致某个 follower 的选举计时器超时了&lt;/li>
&lt;li>Candidate -&amp;gt; Follower：如果 candidate 收到其他 server 的 AppendEntries RPC 宣称是 leader，并且其 term 不小于 candidate 的当前 term，则该 leader 合法，candidate 回退到 follower 状态&lt;/li>
&lt;li>Candidate -&amp;gt; Candidate：如果没有产生多数票，在超时后选举将重复进行，为了打破僵局 Raft 使用随机的选举超时时间&lt;/li>
&lt;li>无论何时，candidate 和 leader 只要收到一个 term 比自己大的 RPC，它必须转变为 follower&lt;/li>
&lt;/ul>
&lt;p>由于在任何一个 term 中，一个 server 只能够投一次票，而只有得到多数票才能成为 leader，所以 Election Safety（一个任期中只有一个 leader）得以满足。&lt;/p>
&lt;h3 id="log-复制-replication">log 复制 (replication)&lt;/h3>
&lt;p>log 由 entry 组成，每个 entry 都有一个唯一递增的 log index（可以理解为在数组中的 index）。entry 中包含 term 和给状态机的指令。&lt;/p>
&lt;p>当一个 log entry 能够被应用到状态机上时 (i.e. 当 leader 知道这个 entry 已经被 replicate 到多数 server 上时，但下文会说明一种例外情况), 我们称这个 entry 为 committed. leader 决定哪些 entry 能够 commit，并在下一次 AppendEntries RPC 中将这个状态告知 followers. Raft 保证了 commited entries 是持久的并&lt;strong>最终&lt;/strong>会应用到所有 servers 上。&lt;/p>
&lt;p>leader 维护 &lt;code>commitIndex&lt;/code>，即最高的 committed entry index，并且会将这个 index 包含在 AppendEntries RPC 中。&lt;/p>
&lt;p>Raft 协议中的 Log Matching 性质实际上由两部分组成：&lt;/p>
&lt;ul>
&lt;li>如果两份 log 中某一个 entry 的 index 和 term 相同, 那么这两个 entry 相同
&lt;ul>
&lt;li>这是因为一个 term 只有一个 leader，而一个 leader 对于给定 log index 只能创建最多一个 entry，并且 log entry 从不改变它们在 log 中的位置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果两份 log 中某一个 entry 的 index 和 term 相同, 它们之前的 entries 都是相同的
&lt;ul>
&lt;li>这个性质由 AppendEntries 的一个一致性检查保证。leader 会把新 entries 的前一个 entry 的 index 和 term 包含在 AppendEntries RPC 中（&lt;code>prevLogIndex&lt;/code> 和 &lt;code>prevLogTerm&lt;/code>），这样如果 follower 找不到这样一个 entry，它就会拒绝新的 entries&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="./image-20230907180012141.png" alt="image-20230907180012141">&lt;/p>
&lt;p>正常情况下所有 server 的 log 会保持一致，然而当 leader crash 时便会产生不一致。follower 可能会缺一些 entries，也可能多一些，也可能两者都有。leader 通过强制 follower 的 log 和自己同步来解决不一致。leader 为每个 follower 维护一个 &lt;code>nextIndex&lt;/code>，即下一个将会被发给 follower 的 log entry。在一开始 leader 会初始化 &lt;code>nextIndex&lt;/code> 为它最新一个 log entry 的下一个位置，当某个 follower 拒绝了一次 AppendEntries 之后，leader 递减 &lt;code>nextIndex&lt;/code> 并重试 AppendEntries RPC。最终 &lt;code>nextIndex&lt;/code> 会到达一个 leader 和 follower 都一致的位置，follower 在那个位置之后的所有 entries 都会被 leader 的覆盖。上述描述同时也符合了 Leader Append-Only（leader 只会追加自己的 log） 这个性质。&lt;/p>
&lt;h3 id="安全性">安全性&lt;/h3>
&lt;p>如果 Figure 7 中的 (f) 被选举为了下一个 leader，那么 term 4 及之后的更改岂不是都丢失了？因此 Raft 限制了谁能够被选为 leader，以便满足 Leader Completeness 性质（committed entry 会存在于任何更高任期的 leader 的 log 中）。首先给出 log 新旧的定义：如果 candidate 的 log 至少和多数 log 一样新（at least as up-to-date as any other log in the majority）那么它包含了所有 committed entries；如果 log 的最后一个 entry term 更大，那么它就更新。如果 term 相同，那么更长的 log 更新。在 RequestVote RPC 中，candidate 会包含 &lt;code>lastLogIndex&lt;/code> 和 &lt;code>lastLogTerm&lt;/code>，只有当 candidate 的 log 更新时一个 server 才会投票给它。&lt;/p>
&lt;p>&lt;img src="./image-20230909175357672.png" alt="image-20230909175357672">&lt;/p>
&lt;p>当 leader commit 一个来自它之前 term 的 entry 时，可能会遭遇上图的问题，在 (c) 中，来自 term 2 的 entry 已经被复制到多数 server 上了，然而如果 (d) 发生了，它仍然会被来自 term 3 的 entry 覆盖。因此 Raft 将 commit 定义为只有来时当前 term 的 entry 才能够通过 replica 计数来 commit，而来自之前任期的 entry 只能够通过在它之后的 entry 被 commit 来间接 commit（Log Matching 性质）。&lt;/p>
&lt;p>我们可以用反证法来证明这么做的安全性（非严格证明），假设节点数量为 2f+1，log index m 已经被 commit 了，并且位于 f+1 个 server 上。此时一个不包含 m 的 server x 想要竞选 leader。为了得到多数票，至少有一个包含 m 的 server y需要投票给 x，此时需要 x 比 y 更新。根据 up-to-date 的定义，可能有以下两种情况：&lt;/p>
&lt;ul>
&lt;li>x 和 y 的最后一个 log entry term 相同，且 x 的 log 至少和 y 一样长。此时根据 Log Matching 性质，x 必然包含 m，故产生矛盾。&lt;/li>
&lt;li>x 的最后一个 log entry（设为 p）term 更大。那么 p 的 term 必然大于 m 的 term。既然 m 已经 commit 了，创建了 p 的那一任 leader 必然在 log 中包含了 m，所以 x 也必然包含 m，产生矛盾。&lt;/li>
&lt;/ul>
&lt;h3 id="时机和可用性">时机和可用性&lt;/h3>
&lt;p>在 leader 选举中，时机（Timing）是很关键的，如果 RPC 用时过长，那么 candidate 在超时之前将无法赢得选举。Raft 需要满足以下时机约束：$broadcastTime ≪ electionTimeout ≪ MTBF$，broadcastTime 是平均一次 RPC 的时间，electionTimeout 是选举超时时间，MTBF（Mean Time Between Failures）是发生两次 server 故障的平均间隔时间。&lt;/p>
&lt;h2 id="集群成员变更">集群成员变更&lt;/h2>
&lt;p>这里指的是增减 server。虽然我们总是能够通过下线整个集群、更新配置、上线集群的方式来增减 server，但这样就减少了可用性。为了使配置变更是安全的，必须保证同一 term 不可能有两个 leader 被选举出来。然而，任何直接由旧配置转变为新配置的做法都是不安全的，如下图所示：&lt;/p>
&lt;p>&lt;img src="./image-20230928111923370.png" alt="image-20230928111923370">&lt;/p>
&lt;p>为了保证安全性，Raft 采取了一种两阶段的策略，集群会切换到一个过渡的配置，称为 joint consensus。论文没有给出这个过程的具体实现，我对这部分也理解得不是很清楚。&lt;/p>
&lt;h2 id="log-压缩compaction">log 压缩（compaction）&lt;/h2>
&lt;p>如果没有压缩，log 的大小会无限增长，并且在 server 故障重启后重新应用 log 的时间会非常长，这显然是不划算的。&lt;/p>
&lt;p>快照（snapshot）是最简单的压缩方式。在一次快照中，当前的系统状态被写入到非易失存储中，然后到这个时刻的所有 log 将被丢弃。&lt;/p>
&lt;p>&lt;img src="./image-20230928141311077.png" alt="image-20230928141311077">&lt;/p>
&lt;p>然而，快照带来了新的复杂度。如果一个 leader 的 log 如上图所示，在一次快照之后 log 中的第一个 entry 为 6，但是如果一个 follower 的 log 还停留在最后一个 entry 为 4，那么这个 follower 永远无法获得 entry 5 了。Raft 的做法是引入了一个新的 InstallSnapshot RPC，用于把 leader 的当前 snapshot 发送给 follower。&lt;/p>
&lt;p>snapshot 的创建过程依赖于上层应用，因为 Raft 对于状态机里的状态知之甚少。但是何时创建 snapshot 由 Raft 决定，一个简单的策略是当 log 达到固定大小时创建。&lt;/p>
&lt;p>每个 server 能够独立创建 snapshots，因而其偏离了 Raft 的强 leader 原则，但是由于在创建 snapshot 时共识已经达成了，所以这不会有问题。如果只有 leader 能创建 snapshot，那么有两个缺点 a) 每次发送 snapshot 都会浪费网络带宽 b) leader 的实现会变得复杂，因为它必须同时发送 snapshot 和新的 entries。&lt;/p>
&lt;h2 id="客户端交互">客户端交互&lt;/h2>
&lt;p>client 只会和 leader 交互，在 client 刚启动时，它可能会连接到一个随机的 server，若该 server 不为 leader，则 server 会拒绝这个请求并提供 leader 的信息。&lt;/p>
&lt;p>Raft 的目标是提供可线性化（linearizable）的语义，即每个操作会在调用和回复之间的某个时间立刻执行执行一次（exactly once）。然而，Raft 可能会执行一个操作多次，如果 leader 在 commit log entry 之后回复 client 之前崩溃了，client 会重试请求，导致一个操作执行了两次。这个问题的解决方案是每个 client 为对每个操作分配一个递增的序列号，leader 维护每个 client 最新的序列号。如果 leader 收到了一个请求包含已经被执行的序列号，那么它就不会再次执行这个请求。&lt;/p>
&lt;p>我们能够不向 log 写任何东西就处理读请求（Read-only operations），然而如果没有额外的措施，读请求可能会读到过时的（stale）数据。如由于网络分区当前 leader 已经被新的 leader 取代了，但是当前 leader 并不知道这一点。为了保证不会读到过时的数据，在 leader 刚当选时它必须发送一个 no-op entry，以便找出哪些 entry 已经 commit 了。其次 leader 必须检查它是否被新的 leader 取代了，这可以通过发送心跳包来检查是否有多数 server 回应来实现。&lt;/p>
&lt;h2 id="notes">Notes&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Raft 是强一致性的协议，因为 commit 过的 log 总是一致的，如果出现网络分区则只有多数区能够达成共识，所以其符合了 CAP 原则中的 CP。另一种应对 split-brain 的方式是允许 split-brain，在网络恢复之后通过一些机制来调谐分叉的状态（reconcile the diverging state），通常这被称为最终一致性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Q：一个 Raft 集群通常位于一个物理位置还是说可以部署在地理上不同的数据中心里？&lt;/p>
&lt;p>A：典型的部署方式是一个数据中心。我们会在之后看到一些运行 Paxos 的系统（如 Spanner）能够跨数据中心，其通常是一种无 leader 的设计，以便一个 client 能够同一个本地 server 通信。&lt;/p>
&lt;p>Google 的 Chubby 论文报告了它们的 Chubby 部署通常是在一个数据中心里，除了 root Chubby 是跨数据中心的（chubby 并未使用 raft，而是用了基于 Paxos 的一个内部库）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="可线性化linearizability">可线性化（Linearizability）&lt;/h2>
&lt;p>并发和不确定性的存在，导致分布式系统很容易存在一些微妙的 bug。除非使用形式化方法，否则我们只能依赖测试来验证系统的正确性。&lt;/p>
&lt;p>通过 Linearizability 这样一种一致性模型，我们可以基于一种顺序的规格形式地确定并发操作的正确性。在一个 linearizable 的系统中，每个操作看起来是在调用和回复之间的某个时间点原子、瞬间执行。可线性化可以被视作强一致性的同义词。&lt;/p>
&lt;blockquote>
&lt;p>Definition of linearizability:&lt;/p>
&lt;p>Execution history is linearizable if there exists a total order of the operations in the history that matches real time for non-concurrent requests. Each read sees the value of the most recent write in order.&lt;/p>
&lt;/blockquote>
&lt;p>下图所示的执行历史是可线性化的：&lt;/p>
&lt;p>&lt;img src="./image-20231001151607479.png" alt="image-20231001151607479">&lt;/p>
&lt;p>而下图则不是：&lt;/p>
&lt;p>&lt;img src="./image-20231001151618755.png" alt="image-20231001151618755">&lt;/p>
&lt;p>我的理解是 Linearizability 是从外部观测获得的一种性质，它并没有说明具体的实现。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>Raft 论文&lt;/li>
&lt;li>&lt;a href="https://pdos.csail.mit.edu/6.824/papers/raft-faq.txt">6.824 Raft FAQ&lt;/a>&lt;/li>
&lt;/ul>
- https://blog.coherence.codes/posts/2023/mit_6.824_2_raft/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>git 入门</title><link>https://blog.coherence.codes/posts/2023/git_%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/git_%E5%85%A5%E9%97%A8/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/git_%E5%85%A5%E9%97%A8/ -&lt;p>本文的大部分内容来自于 &lt;a href="https://git-scm.com/book/en/v2">Pro Git&lt;/a> 这本书。&lt;/p>
&lt;h2 id="objects">Objects&lt;/h2>
&lt;p>git 中最基础的元素是 object，每个 object 由一个 object ID (OID) 唯一标识，OID 是一个 160 bits （用 hex 字符串表示为四十个字符） 的 SHA-1 哈希。具体而言，git 中主要存在三种 objects：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>blobs&lt;/code>: 存储文件内容，OID 即为文件内容的哈希&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>trees&lt;/code>: 一个文件名（path entries）的有序列表，OID 为这个列表的哈希。列表的每一行如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>100644 blob 1fc4aa8f76027dd0fb8f9b533810770236d5c234 .gitignore
&lt;/code>&lt;/pre>&lt;p>容易推测这几个字段分别为权限、object 类型、哈希、文件名。子目录同样是 trees。项目的根目录即为 root tree。所有的 trees 构成了一棵 Merkle tree，&lt;del>所以 git 就是区块链（即答&lt;/del>。下图中三角代表 trees，方块为 blobs&lt;/p>
&lt;p>&lt;img src="./image-20230918111328708.png" alt="image-20230918111328708">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>commits&lt;/code>: 一个&lt;strong>快照&lt;/strong>（snapshot），每个 commit 包含了一个到根 tree 的引用，和一个（或多个）到 parent 的引用。parent 就是上一个 commit 的 OID。在一个 merge commit 中会包含多个 parents。由于 Commit 存储的是快照而不是 diff，所以 Git checkout（切换分支）的速度很快。下图中圆形代表 commits&lt;/p>
&lt;p>&lt;img src="./image-20230918111515508.png" alt="image-20230918111515508">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>objects 的特性决定了它们是不可变的，一旦修改了某个 object 中的内容，哈希将会改变，因而会生成一个新的 object.&lt;/p>
&lt;p>可以使用 &lt;code>git cat-file -t&lt;/code> 来检查一个 object 的类型，用 &lt;code>git cat-file -p&lt;/code> 来打印其内容，以本博客的 git 仓库为例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit 10142e0fb1f636288c7f5a6a164e67c1efc13ef4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Author: Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Date: Tue Sep &lt;span style="color:#ae81ff">5&lt;/span> 17:30:57 &lt;span style="color:#ae81ff">2023&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> The Google File System
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -t 10142e0fb1f636288c7f5a6a164e67c1efc13ef4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -p 10142e0fb1f636288c7f5a6a164e67c1efc13ef4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tree f1f161d92d0c7341ed35e76a66855383334005ab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parent 0e72a3f169a8bbc80904ab7750d3c37853a31dc7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>author Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1693906257&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>committer Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1693906257&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgsig -----BEGIN PGP SIGNATURE-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;omitted&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -----END PGP SIGNATURE-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The Google File System
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -p f1f161d92d0c7341ed35e76a66855383334005ab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">040000&lt;/span> tree 9a76f18c0bca57de0ecf8b9bf15e0e9b7adf5621 .github
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100644&lt;/span> blob 1fc4aa8f76027dd0fb8f9b533810770236d5c234 .gitignore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100644&lt;/span> blob 0b47f42f9ec57c58c474dc1f335e14163dd7a549 .gitmodules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">040000&lt;/span> tree f5b1aa13654d360771df3da98296ac958d537d88 archetypes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100644&lt;/span> blob 8c082a36fd3b90a9e77ec19b17deceb47665e4c7 config.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">040000&lt;/span> tree 81200165da89a43766f03762e4a8d8443357f1ed content
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">040000&lt;/span> tree 336e0cfa73193fc3f76ba2b2de182e82b010f599 themes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些 objects 都被存在项目的 &lt;code>.git/objects&lt;/code> 目录下，由 SHA-1 的前两个字符作为子目录的文件名，后 38 个字符为 object 的文件名。这些 objects 使用 zlib 压缩，根据 &lt;a href="https://unix.stackexchange.com/questions/22834/how-to-uncompress-zlib-data-in-unix">stackoverflow 上的魔法&lt;/a>，可以用 gzip 来解压这些文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ll .git/objects/10/142e0fb1f636288c7f5a6a164e67c1efc13ef4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> cjc cjc &lt;span style="color:#ae81ff">833&lt;/span> Sep &lt;span style="color:#ae81ff">5&lt;/span> 17:30 .git/objects/10/142e0fb1f636288c7f5a6a164e67c1efc13ef4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ printf &lt;span style="color:#e6db74">&amp;#34;\x1f\x8b\x08\x00\x00\x00\x00\x00&amp;#34;&lt;/span> | cat - .git/objects/10/142e0fb1f636288c7f5a6a164e67c1efc13ef4 | gzip -dc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit 1098tree f1f161d92d0c7341ed35e76a66855383334005ab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parent 0e72a3f169a8bbc80904ab7750d3c37853a31dc7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>author Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1693906257&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>committer Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1693906257&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgsig -----BEGIN PGP SIGNATURE-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;omitted&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -----END PGP SIGNATURE-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The Google File System
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gzip: stdin: unexpected end of file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ printf &lt;span style="color:#e6db74">&amp;#34;\x1f\x8b\x08\x00\x00\x00\x00\x00&amp;#34;&lt;/span> | cat - .git/objects/10/142e0fb1f636288c7f5a6a164e67c1efc13ef4 | gzip -dc &amp;gt; test.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gzip: stdin: unexpected end of file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sha1sum test.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10142e0fb1f636288c7f5a6a164e67c1efc13ef4 test.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SHA-1 与 commit 的 OID 一致。&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;p>objects 虽然简洁明了，但是它的名字太不好记了。所以 git 引入了 references (或 refs) 作为对某个 object 的引用，它们被存储在 &lt;code>.git/refs&lt;/code> 中，这就是分支。我们可以通过 &lt;code>git update-ref refs/heads/xxxx hash&lt;/code> 来更新/新建一个 ref，&lt;code>git branch&lt;/code> 命令基本等同于使用 &lt;code>update-ref&lt;/code> 创建一个指向当前分支最后一个 commit 的 ref。&lt;/p>
&lt;p>git 通过一个特殊的 HEAD 文件来获得当前分支最后一个 commit 的信息，通常情况下 HEAD 是对某个 ref 的引用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat .git/HEAD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ref: refs/heads/source_hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是当我们 checkout 一个 tag/commit/远程分支时，我们就会进入到所谓的 &amp;ldquo;detached HEAD&amp;rdquo; 状态：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git checkout f25ea89160baa34af6587ebc4399cba9b82152ab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Note: switching to &lt;span style="color:#e6db74">&amp;#39;f25ea89160baa34af6587ebc4399cba9b82152ab&amp;#39;&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>You are in &lt;span style="color:#e6db74">&amp;#39;detached HEAD&amp;#39;&lt;/span> state. You can look around, make experimental
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>changes and commit them, and you can discard any commits you make in this
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>state without impacting any branches by switching back to a branch.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>If you want to create a new branch to retain commits you create, you may
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span> so &lt;span style="color:#f92672">(&lt;/span>now or later&lt;span style="color:#f92672">)&lt;/span> by using -c with the switch command. Example:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> git switch -c &amp;lt;new-branch-name&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Or undo this operation with:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> git switch -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Turn off this advice by setting config variable advice.detachedHead to false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HEAD is now at f25ea8916 fix: Add CHANGELOG link
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这种状态作出的 commits 将成为 dangleing commits，因为没有 refs 能够间接引用到它们。我们可以在 &lt;code>git reflog&lt;/code> 中看到它们，但它们在一段时间后可能会被 git 垃圾回收掉。如果因为误操作“丢失”了一些 commit，大部分情况下只是没有 ref 能够间接引用它们了，所以我们能在 reflog 中找到并恢复它们。&lt;/p>
&lt;p>除了分支之外，另一种 ref 是 tag。tag 被存储在 &lt;code>.git/refs/tags&lt;/code> 中，和 branch 不同的是，tag 是不可变的。git 中有两种类型的 tag：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>lightweight tag: 使用 &lt;code>git tag&lt;/code> 创建，其 ref 直接指向一个 commit&lt;/p>
&lt;/li>
&lt;li>
&lt;p>annotated tag: 使用 &lt;code>git tag -a&lt;/code> 创建，需要像 commit 一样写一段 tag message，其 ref 指向 git 中的第四种 object 类型，tag。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git tag -a v1.2.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cat .git/refs/tags/v1.2.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>295e429586c0dc7764077b7ec3b15402b9299532
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -t 295e429586c0dc7764077b7ec3b15402b9299532
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -p 295e429586c0dc7764077b7ec3b15402b9299532
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>object 0996cddadea886287fd606b4102304814eb3785c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>type commit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tag v1.2.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tagger Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1695018502&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>xxxxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#75715e"># object 字段就是对 commit 的引用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -t 0996cddadea886287fd606b4102304814eb3785c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是 tag 并不是必须指向一个 commit，tag 任何 object 都是可以的。虽然在实践中好像 tag 非 commit 并没有什么用..&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git tag -a tree-tag 9ff1e32671b9ac918dd665020c8da93c44787e33
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cat .git/refs/tags/tree-tag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3b94c91c60f92b16336050aa445c7a293e61ec2e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -p 3b94c91c60f92b16336050aa445c7a293e61ec2e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>object 9ff1e32671b9ac918dd665020c8da93c44787e33
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>type tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tag tree-tag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tagger Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1695018786&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a tag &lt;span style="color:#66d9ef">for&lt;/span> tree
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="merge-and-rebase">Merge and Rebase&lt;/h2>
&lt;p>最简单的 merge 类型是 fast-forward，git 简单地移动 ref 来完成 merge。另一种常见的 merge 如图所示：&lt;/p>
&lt;p>&lt;img src="./basic-merging-1.png" alt="Three snapshots used in a typical merge">&lt;/p>
&lt;p>我们想要在 master 分支上执行 &lt;code>git merge iss53&lt;/code>，git 会找到三个 commits，C5、C4 和它们的共同祖先 C2，然后执行&lt;a href="https://stackoverflow.com/questions/4129049/why-is-a-3-way-merge-advantageous-over-a-2-way-merge">三方合并&lt;/a> (three-way merge)，high-level 地看，git 需要把每个 commit 的 tree 划分成一个一个 chunk，chunk 可以是文件，或文件的一块，或行，这由具体的 merge 策略决定。git 会比较这些 chunks，对于某一个 chunk：&lt;/p>
&lt;ul>
&lt;li>如果在 C2、C4、C5 中都相等，则不作更改&lt;/li>
&lt;li>如果 C2、C4 相等，但和 C5 不等，取 C5 的版本，反之同理&lt;/li>
&lt;li>如果 C4、C5 相等，和 C2 不等，那么两个分支作了同样的更改，取任何一个版本&lt;/li>
&lt;li>如果三者都不相等，则发生 merge 冲突，需要手动处理&lt;/li>
&lt;/ul>
&lt;p>如果我们不寻找 C2，只比较 C4、C5，这就是所谓的 two-way merge，由于失去了祖先的信息，我们无法处理第二种情况。实际进行 merge 时，我们可能会看到如下信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git merge b1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Auto-merging 1.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Merge made by the &lt;span style="color:#e6db74">&amp;#39;ort&amp;#39;&lt;/span> strategy.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1.txt | &lt;span style="color:#ae81ff">1&lt;/span> +
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> file changed, &lt;span style="color:#ae81ff">1&lt;/span> insertion&lt;span style="color:#f92672">(&lt;/span>+&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个过程中，git 会创建一棵新 tree，把两个分支作为 parent 创建一个新的 commit，这就是 merge commit。&lt;/p>
&lt;p>rabase 则是完全不同的方式。如果 cherry-pick 一个 commit：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git cherry-pick 2f6c412
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>master 2aa02d0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Date: Tue Sep &lt;span style="color:#ae81ff">19&lt;/span> 16:32:32 &lt;span style="color:#ae81ff">2023&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> file changed, &lt;span style="color:#ae81ff">1&lt;/span> insertion&lt;span style="color:#f92672">(&lt;/span>+&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本质上是 diff 2f6c412 和 2f6c412 的 parent，然后在当前分支重新应用这个 diff。rebase 本质上是自动的 cherry-pick。&lt;/p>
&lt;p>&lt;img src="./basic-rebase-1.png" alt="Simple divergent history">&lt;/p>
&lt;p>在 experiment 分支执行 &lt;code>git rebase master&lt;/code> 则会找到 experiment 和 master 的共同祖先 C2，然后发现 experiment 分支有一个新的 commit C4，git 会在 master 重做这个 commit。&lt;/p>
&lt;h2 id="一个-fsck-导致的问题">一个 fsck 导致的问题&lt;/h2>
&lt;p>某日我在检查软件更新时，发现 KeePassDX f-droid 版没有随着上游更新，进而发现了&lt;a href="https://github.com/Kunzisoft/KeePassDX/issues/1333">这个 issue&lt;/a>，问题的原因是 KeePassDX 的仓库中有几个 tree object 不合法，运行 &lt;code>git fsck&lt;/code> 会报错 &lt;code>error in tree b7a0b493966f9077f6fcd7de37244699bb73615e: duplicateEntries: contains duplicate file entries&lt;/code>。&lt;/p>
&lt;p>git 不允许一个 tree 中含有两个相同的文件名，但是不知为何这个错误发生了（包含这个 tree 的 commit 可以追溯到 2009 年，可能是由于 Windows 不区分文件名大小写且在上古时期 git 处理这个的逻辑有问题）。而 f-droid 在几个月前启用了 git clone 时的 fsck 检查（&lt;code>transfer.fsckObjects&lt;/code> 等配置），导致 build 时 clone 仓库失败。顺便一提 Github push 现在也有 git fsck 检查，所以把这个仓库往另一个仓库 push 也会失败。&lt;/p>
&lt;p>fsck 失败的问题在多个仓库出现过，包括&lt;a href="https://github.com/highlightjs/highlight.js/issues/1733">highlight.js&lt;/a>, &lt;a href="https://github.com/Behat/Behat">Behat&lt;/a>, &lt;a href="https://github.com/psf/requests/issues/2690">requests&lt;/a>，无一例外都能追溯到某些上古 commit，目前看来除了重写所有 commits 并没有什么办法来修复这些错误。我尝试了 &lt;a href="https://stackoverflow.com/questions/10931954/git-tree-contains-duplicate-file-entries">replace 的魔法&lt;/a>发现并不能够使其通过 git fsck（毕竟出错的 tree 还在）。&lt;/p>
&lt;p>回到 KeePassDX 的问题只能让 f-droid 在 clone 的时候做一些 workaround 来绕过了&amp;hellip;&lt;/p>
- https://blog.coherence.codes/posts/2023/git_%E5%85%A5%E9%97%A8/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>MIT 6.824 学习笔记(一) GFS</title><link>https://blog.coherence.codes/posts/2023/mit_6.824_1_gfs/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/mit_6.824_1_gfs/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/mit_6.824_1_gfs/ -&lt;p>存储系统通常是一个分布式系统的基石，通常应用可以是无状态的，而所有状态便由存储系统来管理。&lt;/p>
&lt;p>Google 文件系统（The Google File System, GFS）在 2003 年于一篇同名论文中被提出，发表在系统领域顶会 SOSP 上，是 Google 大数据三驾马车之一&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。GFS 是一个成功的系统，在 00 年代早期，人们对于分布式文件系统已经有很好的理解了，但是尚未有一个可以扩展到上千个节点的系统被实现出来。很多 GFS 的设计被 HDFS 等后来的分布式文件系统上。&lt;/p>
&lt;p>GFS 基于以下几个方面的观察：&lt;/p>
&lt;ul>
&lt;li>节点故障是常见的，因为其运行在大量普通机器（commodity components）上&lt;/li>
&lt;li>存储的文件以大文件（数百 MB 到数 GB）为主，小文件应当被支持，但不应对其优化&lt;/li>
&lt;li>对文件的大多数写入操作是追加 （append）而不是覆盖/随机写，大多数读取操作是顺序读 （1 MB 或更多）
&lt;ul>
&lt;li>所以系统必须有良好的并发追加操作的语义&lt;/li>
&lt;li>工作负载通常是批处理任务，所以高吞吐量比低延时重要&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>同时设计应用和文件系统 API 有利于整个系统的灵活性&lt;/li>
&lt;/ul>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;img src="./image-20230901145431686.png" alt="image-20230901145431686">&lt;/p>
&lt;p>GFS 采用 Master/Slave 架构，集群中存在一个 master 和多个 chunkservers，并且被多个 clients 访问。（由于单 master 的存在，GFS 存在单点故障的可能性，虽然 master 同样有备份，但恢复可能需要人工干预）一个文件将被分割成多个 chunk。chunk 的特性如下：&lt;/p>
&lt;ul>
&lt;li>固定大小，Google 的选择是 64 MB，这么大的 chunk 将有如下好处：
&lt;ul>
&lt;li>减少 client 和 master 的通信，因为在获取到 chunk 的信息后，client 只需要和 chunkserver 交互进行读写&lt;/li>
&lt;li>减少 metadata 的尺寸，以便所有 metadata 可以保存在内存中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>作为一个普通的 Linux 文件存储在 chunkserver 上&lt;/li>
&lt;li>每个 chunk 由一个不可变的、唯一的 64 位 chunk handle 标记，其由 master 在 chunk 创建时指定
&lt;ul>
&lt;li>chunkserver 根据 chunk handle 和偏移（byte range）来读写 chunk&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为了可靠性，每个 chunk 会被复制到多个 chunkservers 上 （通常为三个）&lt;/li>
&lt;/ul>
&lt;p>master 管理了所有的元数据，用 Go 代码大概表示为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ChunkHandle&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Handle&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ChunkServers&lt;/span> []&lt;span style="color:#a6e22e">ChuckServer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ReplicaNum&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Version&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#75715e">// 为了区分数据是否是最新的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Primary&lt;/span> &lt;span style="color:#a6e22e">ChuckServer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LeaseExpiration&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Master&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span> &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#a6e22e">Filename&lt;/span>][]&lt;span style="color:#a6e22e">ChunkHandle&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除此之外，还需要 log 和 checkpoint 机制来持久化元数据。元数据中 Handle, ReplicaNum 和 Version 应该是非易失的（non-volatile)。没有持久化 ChunkServers 字段可能是因为 chunkserver 会经常变动。&lt;/p>
&lt;h2 id="一致性模型">一致性模型&lt;/h2>
&lt;p>GFS 采用了一种宽松的一致性模型，不同于 Raft 等强一致性协议，其允许不一致的情况出现。不一致的情况将由应用处理。这实际上是为了性能而牺牲了一些一致性。&lt;/p>
&lt;p>&lt;img src="./image-20230901182949527.png" alt="image-20230901182949527">&lt;/p>
&lt;p>对于一个文件区域，GFS 定义了几种状态：&lt;/p>
&lt;ul>
&lt;li>一致的（consistent）：无论从哪个 replica 读，所有 clients 都会看到同样的数据&lt;/li>
&lt;li>确定的（defined）：在一次写入之后，数据是一致的，并且 clients 都能完整看到这次写入写了什么。&lt;/li>
&lt;li>不一致的（inconsistent）：不同的 client 能够读到不一样的结果&lt;/li>
&lt;/ul>
&lt;p>这三种状态发生于以下情况：&lt;/p>
&lt;ul>
&lt;li>当没有并发写的写入成功后，这块区域就是确定的&lt;/li>
&lt;li>当若干写入操作并发成功后，这块文件区域是不确定但一致的：所有 clients 都能看到同样的数据，但这块可能不能反映出其中任何一次写入的结果（通常是这几次写入的结果交织在一起）&lt;/li>
&lt;li>失败的写入使得这块区域不一致&lt;/li>
&lt;/ul>
&lt;p>GFS 中的写入（mutation）分为指定偏移量的写入（Write）和记录末尾追加（Record Append），record append 能够保证原子的至少一次（at least once）追加，但是有小概率会出现 padding 或者重复数据。GFS 的应用可以通过在每条记录后加入校验来处理不完整的记录，还可以通过加入唯一的标识符来处理重复记录。GFS 的客户端库中包含了这些通用的处理不一致的功能。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>GFS 使用租约（lease）来维护一个一致的写入顺序（consistent mutation order）。租约就是在一段时间内，master 让某一 replica 成为 primary，master 将保证在这段时间内不会分配另一个 primary，而 primary 将保证在租约过期后不再履行 primary 的职责。primary 将指定一个 chunk 的写入顺序，其他的 replica 则跟随 primary 的顺序。&lt;/p>
&lt;h3 id="写入">写入&lt;/h3>
&lt;p>&lt;img src="./image-20230905110612114.png" alt="image-20230905110612114">&lt;/p>
&lt;p>client 首先向 master 请求 primary 和其他 replicas 的位置。如果尚未有一个 primary，master 会首先增大版本号并通知所有 replicas，然后选定一个 primary 并向其分配租约。client 会缓存这些元数据，以减少 master 的负载。&lt;/p>
&lt;p>client 随后向所有 replica 推送数据，数据被存储在 chunkserver 的本地缓存中等待被使用。数据流和控制流是分离的，这是为了更有效地利用网络。数据流采用了一种流水线的形式，首先 client 向距离其最近的 chunkserver 推送数据，这个 chunkserver 再向其最近的 chunkserver 转发，链式地发送数据，转发不会等待 chunk 传输完而是立即开始的。&lt;/p>
&lt;p>当所有 repicas 都 ACK 收到了数据之后，client 向 primary 请求写入。由于可能存在并发，primary 为所有写入分配一个序列号，在本地应用这些写入，并转发写入请求到其他 replicas。所有 replicas 都 ACK 之后，primary 向 client 回复。如果任何一个 replica 出错，那么被修改的区域就处于不一致的状态，此时由 client 来负责重试失败的写入。（如果在 primary 就出错的话，那么它不会转发写入请求，此时数据应该仍然处于一致的状态）&lt;/p>
&lt;p>当应用写入的区域很大时，GFS client 会将其切分成一个一个 chunk，并分为多个写入操作来执行，此时如果有并发操作，则会出现一致但不确定的状态。&lt;/p>
&lt;h3 id="记录追加record-append">记录追加（Record Append）&lt;/h3>
&lt;p>此操作中 client 只指定文件而不指定偏移，GFS 保证该操作在 GFS 指定的偏移处原子地完成至少一次，并向客户端返回这个偏移。GFS 的应用中有很多是多生产者/单消费者模型，很适合使用记录追加操作。&lt;/p>
&lt;p>记录追加操作和写入大致相同，惟 primary 会检查要追加的数据是否会超出当前 chunk，如果会的话，它将 pad 这个 chunk 到 64MB，指示其他 replicas 也这么操作，并指示客户端重试。（记录追加操作限制最大数据大小为四分之一个最大 chunk size 以便控制碎片的大小）如果没有超出，则按写入的流程进行，此时 primary 会选择一个 offset （即它所认为的文件末尾）告知其他 replicas 进行写入。如果任何一个 replica 失败，客户端会重试操作。这种情况下部分 replica 将会出现重复的记录，但是数据肯定以某一偏移写入了所有 replicas。&lt;/p>
&lt;h2 id="问题">问题&lt;/h2>
&lt;ul>
&lt;li>如果 chunk 的版本号只在分配租约是增加的话，假设一个 replica （非 primary）在某一时刻挂了，因此错过了几个写入，如果版本号此时不改变的话，在那个 replica 恢复之后，client 就会读到过时数据了。论文里好像也没提这种情况怎么处理..&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>以上并未包含论文的完整内容。GFS 我早在去年夏天就开始学了，然后就一直搁置在一旁，直到这两天才重新拿起来&amp;hellip;&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>本文的内容来源于：&lt;/p>
&lt;ul>
&lt;li>GFS 论文&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=EpIgvowZr00&amp;amp;t=1935s">6.824 Lecture 3: GFS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mr-dai.github.io/gfs/">Google File System 总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>另外两篇论文是 MapReduce: Simplified Data Processing on Large Clusters 和 Bigtable: A Distributed Storage System for Structured Data&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
- https://blog.coherence.codes/posts/2023/mit_6.824_1_gfs/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>神秘的自动关闭显示器失效问题</title><link>https://blog.coherence.codes/posts/2023/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/ -&lt;h2 id="问题">问题&lt;/h2>
&lt;p>我的桌面环境为 KDE/X11，我在 KDE 的 Power Management 设置中设置了 &lt;code>Screen Energy Saving: Switch off after 5 min&lt;/code>，这个选项时不时地出问题，表现为刚开机时能够正常工作，在闲置五分钟后关闭显示器，但在一段时间过后就不行了，这个一段时间可长可短。重启电脑又能重新工作，而锁屏后也能够正常工作。这个问题从我用 KDE 开始就一直困扰着我，时至今日。&lt;/p>
&lt;h2 id="排查">排查&lt;/h2>
&lt;p>KDE 的电源管理由 powerdevil 控制，其作为 &lt;code>plasma-powerdevil.service&lt;/code> 用户服务运行，查询日志发现有一些神秘的 &lt;code>org_kde_powerdevil[1310]: QObject::disconnect: Unexpected nullptr parameter&lt;/code> 报错，之后证实该报错与本问题无关。&lt;/p>
&lt;p>查看该 &lt;code>.service&lt;/code> 文件发现其使用 &lt;code>Type=dbus&lt;/code> 的启动类型，并且获得了一个叫 &lt;code>org.kde.Solid.PowerManagement&lt;/code> 的 bus name。用 QBBusViewer 可以看到 powerdevil 还提供了 &lt;code>org.freedesktop.PowerManagement&lt;/code> 这一服务。&lt;/p>
&lt;p>查阅 powerdevil 源码以 &lt;code>Switch off after&lt;/code> 为关键词进行搜索可发现相关逻辑位于 &lt;code>daemon/actions/bundled/dpms.cpp&lt;/code> 文件下，根据名字猜测 dpms 即 Display Power Management Signaling 的缩写。简单看了一下 dpms，这是一个古老的协议，在 1993 年发布，定义了四种模式，但 &lt;a href="https://wiki.archlinux.org/title/Display_Power_Management_Signaling">archwiki 上&lt;/a>指出：&lt;/p>
&lt;blockquote>
&lt;p>Note that DPMS was developed for CRT monitors, and on LCD displays, there is normally no difference between the standby, suspend and off modes.&lt;/p>
&lt;/blockquote>
&lt;p>顺便插一句，流传甚广的关闭显示器的命令 &lt;code>xset dpms force off&lt;/code> 即强制 dpms 进入 off 模式。&lt;/p>
&lt;p>在 &lt;a href="https://invent.kde.org/plasma/powerdevil/-/blob/master/daemon/actions/bundled/dpms.cpp#L108">dpms.cpp#L108&lt;/a> 发现在一定条件下空闲超时关闭显示器的函数会直接返回，猜测这个 inhibit 的条件是由上述的两个 dbus 服务来控制的。&lt;/p>
&lt;p>尝试调用上述 dbus 服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ qdbus --literal org.kde.Solid.PowerManagement /org/kde/Solid/PowerManagement/PolicyAgent org.kde.Solid.PowerManagement.PolicyAgent.ListInhibitions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Argument: a&lt;span style="color:#f92672">(&lt;/span>ss&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{[&lt;/span>Argument: &lt;span style="color:#f92672">(&lt;/span>ss&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/usr/lib/chromium/chromium&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Capturing&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>, &lt;span style="color:#f92672">[&lt;/span>Argument: &lt;span style="color:#f92672">(&lt;/span>ss&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/usr/lib/chromium/chromium&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Capturing&amp;#34;&lt;/span>&lt;span style="color:#f92672">]}]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ qdbus --literal org.kde.Solid.PowerManagement /org/freedesktop/PowerManagement org.freedesktop.PowerManagement.Inhibit.HasInhibit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>发现疑似是 chromium 在 Inhibit，结合阻止理由，很容易想到是我用的&lt;a href="https://chrome.google.com/webstore/detail/imhcgcnjkibjikdbdgnhclihigkooeaf">音量插件&lt;/a>导致的，其原理就是 Capture 当前页面而获得一个相关的音频 API。在关闭了相应标签页之后问题解决。&lt;/p>
&lt;h2 id="疑问">疑问&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>org.freedesktop.PowerManagement&lt;/code> API 似乎并没有成为标准，虽然似乎主流的桌面环境都实现了。用 Google 搜索只能搜索到&lt;a href="https://www.freedesktop.org/wiki/Specifications/power-management-spec/">这个页面&lt;/a>，提示：&lt;/p>
&lt;blockquote>
&lt;p>This spec is considered obsolete.&lt;/p>
&lt;/blockquote>
&lt;p>并且页面中 &lt;code>The Spec&lt;/code> 下的链接全都 404 了，另有一个相关的 dbus API &lt;code>org.freedesktop.ScreenSaver&lt;/code>，不知道他们之间的关系是什么。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通常在任务栏的 Power Management 选项卡下会提示哪个应用程序在阻止锁屏，如图所示：&lt;/p>
&lt;p>&lt;img src="./image-20230903202406468.png" alt="image-20230903202406468">&lt;/p>
&lt;p>但是这个提示有时候会不工作&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="workaround">Workaround&lt;/h2>
&lt;p>根据上述描述，这根本不是 bug 而是 feature，但我又时常会使用 chromium 的音量插件，有没有办法绕过呢？&lt;/p>
&lt;p>我尝试手动设置 &lt;code>xset dpms 20 20 20&lt;/code> 并禁用 &lt;code>plasma-powerdevil.service&lt;/code>, 发现在 chromium 没有进行 capture 时 20s 后显示器关闭，而进行 capture 时则不行，怀疑 chromium 除了 &lt;code>org.freedesktop.PowerManagement&lt;/code> dbus API 之外还有其他手段来控制电源管理。&lt;/p>
&lt;p>目前就先不管这个问题了&amp;hellip;&lt;/p>
- https://blog.coherence.codes/posts/2023/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>强制 chromium 使用浅色模式</title><link>https://blog.coherence.codes/posts/2023/%E5%BC%BA%E5%88%B6-chromium-%E4%BD%BF%E7%94%A8%E6%B5%85%E8%89%B2%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 30 May 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/%E5%BC%BA%E5%88%B6-chromium-%E4%BD%BF%E7%94%A8%E6%B5%85%E8%89%B2%E6%A8%A1%E5%BC%8F/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/%E5%BC%BA%E5%88%B6-chromium-%E4%BD%BF%E7%94%A8%E6%B5%85%E8%89%B2%E6%A8%A1%E5%BC%8F/ -&lt;h2 id="问题">问题&lt;/h2>
&lt;p>从前两年开始深色模式大行其道，以至于现在几乎找不到一个不支持深色模式的网站了。各大主流浏览器几乎都在两三年前就支持了 CSS 的 &lt;code>prefers-color-scheme&lt;/code> 媒体查询，从而根据系统/浏览器的主题来自动切换浅/深色模式。在浏览器控制台中使用 &lt;code>window.matchMedia('(prefers-color-scheme: dark)').matches&lt;/code> 即可测试这一 feature。&lt;/p>
&lt;p>我在系统中（KDE, Archlinux）使用深色模式，但我又并不喜欢大多数网站的深色模式，但是许多网站都使用了上述媒体查询来自动切换，导致很多情况下我进入一个网站后第一件事就是把浅色模式给切回来。在 Firefox/Edge 中浏览器设置便提供了深/浅色主题的切换选项，这一选项也是和上述媒体查询绑定的，然而不幸的是，chromium 并没有提供这一选项。&lt;/p>
&lt;h2 id="尝试">尝试&lt;/h2>
&lt;p>根据&lt;a href="https://superuser.com/questions/1430098/force-light-mode-in-google-chrome">这个问题&lt;/a>，我尝试安装了一个浅色主题，或者把 theme color 改成浅色，都没有作用。&lt;/p>
&lt;p>那 flags 呢？&lt;code>#enable-force-dark&lt;/code> 提供了强制开启深色模式的选项，但是我在 &lt;code>chrome://flags&lt;/code> 中将其设置为 disabled 之后，并没有发生什么。&lt;a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1046660">Issue 1046660: Allow users to force web content light/dark mode independent of system setting&lt;/a> 中同样提到设置 &lt;code>#enable-force-dark&lt;/code> 为 disabled 将会被忽略。这个 Issue 应该是最贴近我的需求的一个 issue，然而目前还是 open 状态，距离实现遥遥无期。&lt;/p>
&lt;p>另有一个 command line options &lt;code>--disable-features=WebUIDarkMode&lt;/code>，然而遗憾的是这个 option 仅针对 chromium UI, 对 web page 没有作用。&lt;/p>
&lt;p>就在不久之前，chromium 还不支持随系统的深色模式来切换自己的深色模式（见 &lt;a href="https://bugs.chromium.org/p/chromium/issues/detail?id=998903">Issue 998903: XDG Desktop Portal &amp;ldquo;Prefer dark appearance&amp;rdquo; does not affect prefers-color-scheme media query&lt;/a>），这一 feature 是在四月份实现的，并在 114 中发布。从相应的 &lt;a href="https://chromium-review.googlesource.com/c/chromium/src/+/4375982">revision&lt;/a> 中，我们可以发现 chromium 首先会通过 dbus 和 xdg-desktop-portal 交互，读取 &lt;code>org.freedesktop.appearance&lt;/code> namespace 下的 &lt;code>color-scheme&lt;/code> 字段。根据 &lt;a href="https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.Settings">portal 的定义&lt;/a> 返回值是 1 则偏好深色外观，返回值是 2 则偏好浅色外观。并且这一 revision 中说：&lt;/p>
&lt;blockquote>
&lt;pre tabindex="0">&lt;code>* The portal preference takes precedence over the toolkit preference
&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;p>我并没有找到这里的 toolkit 指的是什么，但我猜测是 chromium 自身的主题。这可能就是主题设置无效的原因。KDE 的 portal 由 xdg-desktop-portal-kde 这个包实现，&lt;a href="https://invent.kde.org/plasma/xdg-desktop-portal-kde/-/blob/863d369156c85c67f96a23d87564f196532372ce/src/settings.cpp#L216">搜索源码发现&lt;/a>它只是简单的判断了窗口背景颜色的灰度：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> windowBackgroundGray &lt;span style="color:#f92672">=&lt;/span> qGray(palette.window().color().rgb());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>uint result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// no preference
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (windowBackgroundGray &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// prefer dark
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// prefer light
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>就感觉很随意&amp;hellip; 所以我在 KDE 设置中更改 Colors 选项中主题的 Window Background 到一个比较浅的背景，就能更改 portal 中的这个值了，试了一下确实是有效的，但是我的其他应用也会变成浅色背景了，这显然不是我想要的。&lt;/p>
&lt;p>&lt;img src="./image-20230530230144145.png" alt="image-20230530230144145">&lt;/p>
&lt;p>我想到了以下几种办法：&lt;/p>
&lt;ul>
&lt;li>hook dbus 请求，给 chromium 返回另一个值，Google 了下没找到什么方法&lt;/li>
&lt;li>让 chromium 的 dbus 请求失败，这样它就会 fallback 到自身的主题设置，同样我并没有找到针对特定应用禁用 dbus 的方法&lt;/li>
&lt;li>patch chromium 源码，这应该是最简单的（显然正确的做法并不简单，只是 hack 的做法简单）&lt;/li>
&lt;li>写一个油猴脚本，在每个网站加载时修改 &lt;code>prefers-color-scheme&lt;/code> 这个媒体查询的返回值，但我没有找到能够在 JS 中修改媒体查询的办法&lt;/li>
&lt;/ul>
&lt;p>最可行的看起来是第三条路了。代价就是长达四个小时的编译时间，以及每次 chromium 更新后都需要重新编译。&lt;/p>
&lt;h2 id="如何-patch">如何 patch&lt;/h2>
&lt;p>如果只是改一个版本的话，直接修改源文件后使用 &lt;code>makepkg -e&lt;/code> 在不重新解压源码的情况下 rebuild 即可。但是版本更新后源码会重新下载，所以还是需要一个 patch 的。我遵循了&lt;a href="https://wiki.archlinux.org/title/Patching_packages">这个 ArchWiki&lt;/a> 来创建一个 patch，但是把源码复制一份实在是太大了，所以我使用 &lt;code>cp --parent&lt;/code> 单独复制了一个文件，然后再 diff：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-patch" data-lang="patch">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">--- chromium-114.0.5735.45/chrome/browser/ui/views/dark_mode_manager_linux.cc 2023-05-25 08:41:45.780152800 +0800
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ new/chrome/browser/ui/views/dark_mode_manager_linux.cc 2023-05-31 12:40:12.308506988 +0800
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -25,7 +25,7 @@
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> constexpr char kReadMethod[] = &amp;#34;Read&amp;#34;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> constexpr char kSettingsNamespace[] = &amp;#34;org.freedesktop.appearance&amp;#34;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> constexpr char kColorSchemeKey[] = &amp;#34;color-scheme&amp;#34;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-constexpr int kFreedesktopColorSchemeDark = 1;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+constexpr int kFreedesktopColorSchemeDark = 2;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scoped_refptr&amp;lt;dbus::Bus&amp;gt; CreateBus() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbus::Bus::Options options;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里改动的是 chromium 从 xdg-desktop-portal 获取到 &lt;code>color-scheme&lt;/code> 之后，判断是否为深色模式的常量，这一改动即可反转 chromium 对于浅/深色模式的判断。&lt;/p>
&lt;p>patch 中第一个文件夹的名字，也就是 &lt;code>chromium-114.0.5735.45&lt;/code> 和 &lt;code>new&lt;/code> 并不重要，因为在 PKGBUILD 中我们会使用 &lt;code>-p1&lt;/code> 来忽略第一个文件夹：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>-p&lt;/strong>num or **&amp;ndash;strip=**num
Strip the smallest prefix containing num leading slashes from each file name found in the patch file.&lt;/p>
&lt;/blockquote>
&lt;p>然后就是编译了，在等待了四个小时之后我终于成功切换回了浅色模式！&lt;/p>
&lt;p>&lt;img src="./image-20230531125453946.png" alt="image-20230531125453946">&lt;/p>
&lt;p>最后还是希望 &lt;a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1046660">Issue 1046660&lt;/a> 能够被尽快解决，让我能够在设置中直接切换浅/暗色模式。&lt;/p>
- https://blog.coherence.codes/posts/2023/%E5%BC%BA%E5%88%B6-chromium-%E4%BD%BF%E7%94%A8%E6%B5%85%E8%89%B2%E6%A8%A1%E5%BC%8F/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>Kubernetes 生态中的航海隐喻</title><link>https://blog.coherence.codes/posts/2023/kubernetes-%E7%94%9F%E6%80%81%E4%B8%AD%E7%9A%84%E8%88%AA%E6%B5%B7%E9%9A%90%E5%96%BB/</link><pubDate>Sun, 30 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/kubernetes-%E7%94%9F%E6%80%81%E4%B8%AD%E7%9A%84%E8%88%AA%E6%B5%B7%E9%9A%90%E5%96%BB/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/kubernetes-%E7%94%9F%E6%80%81%E4%B8%AD%E7%9A%84%E8%88%AA%E6%B5%B7%E9%9A%90%E5%96%BB/ -&lt;blockquote>
&lt;p>Disclaimer: 本文的结论大多是根据名字推断出来的，并没有得到项目开发者的证实。&lt;/p>
&lt;/blockquote>
&lt;p>Kubernetes 在 2014 年 9 月发布，在这之前 Docker 已经大行其道了。Docker 发布于 2013 年，意为码头工人，其 logo 是个鲸鱼驮着一些集装箱。&lt;/p>
&lt;p>&lt;img src="./610px-Docker_(container_engine)_logo.svg.png" alt="File:Docker (container engine) logo.svg">&lt;/p>
&lt;p>后来这个 Logo 又变得扁平了一点：&lt;/p>
&lt;p>&lt;img src="./512px-Docker_logo.svg.png" alt="File:Docker logo.svg">&lt;/p>
&lt;p>很显然这个名字和和 Logo 都与集装箱（container，即容器）有关。&lt;/p>
&lt;p>Kubernetes 这个名字来源于古希腊语 κυβερνήτης，意为舵手（steersman）/领航员（pilot）/船长（captain）。其 logo 是一个舵轮的形状。身为一个容器编排系统，Kubernetes 负责着一艘船的航向，倒也合理。&lt;/p>
&lt;figure>&lt;img src="617px-Kubernetes_logo_without_workmark.svg.png" width="200px"/>
&lt;/figure>
&lt;p>值得一提是和 Kubernetes 共享词源 κυβερνήτης 的还有 governor（州长/统治者/主管）和 cybernetics（控制论）。&lt;/p>
&lt;p>Helm 官方的 slogan 是 Kubernetes 的包管理器，helm 意为舵轮，logo 和 Kubernetes 类似，也是一个舵轮的形状。&lt;/p>
&lt;figure>&lt;img src="helm.svg" width="200px"/>
&lt;/figure>
&lt;p>在 Helm 2 时代，helm 还需要一个部署在集群内的组件 tiller 才能工作。tiller 似乎是舵柄的意思，它和舵直接相连。下图展示了一个舵柄和舵轮的区别：&lt;/p>
&lt;figure>&lt;img src="1280px-Tiller_and_helm_orders.svg.png" width="300px"/>
&lt;/figure>
&lt;p>Argo 项目包含了 CD/Workflows/Rollouts 等一系列项目，总体是和应用交付、CI/CD 相关。在希腊神话中，Argo （阿尔戈号）是一艘船，由伊阿宋等希腊英雄在雅典娜帮助下建成，众英雄乘该船取得金羊毛。此后阿尔戈号作为进献雅典娜的祭品被焚毁，南船座（Argo Navis, or simply Argo）由此而来。Navis 词源为古希腊语，意为船（ship）。但是 Argo 的 logo （应该？）是一只章鱼，很奇怪的联系..&lt;/p>
&lt;figure>&lt;img src="argo.svg" width="200px"/>
&lt;/figure>
&lt;p>cert-manager，虽然名字和航海没什么关系，但它的 logo 是一个锚..&lt;/p>
&lt;figure>&lt;img src="cert-manager.svg" width="200px"/>
&lt;/figure>
&lt;p>上面说到 Argo 就是南船座，南船座本来是天空中最大的星座，但在十八世纪被拆分为四个单独的星座，其中之一为船帆座（Vela），所以 Kubevela 的 logo 是一艘帆船。Kubevela 同样属于负责应用交付的组件，和 ArgoCD 在功能上有重叠和互补的地方。&lt;/p>
&lt;figure>&lt;img src="kube-vela.svg" width="200px"/>
&lt;/figure>
&lt;p>最后要说的是 Harbor，非常直白，就是港口，作为一个 container registry 也很合理，其 logo 是一个灯塔的形状。&lt;/p>
&lt;figure>&lt;img src="harbor.svg" width="200px"/>
&lt;/figure>
- https://blog.coherence.codes/posts/2023/kubernetes-%E7%94%9F%E6%80%81%E4%B8%AD%E7%9A%84%E8%88%AA%E6%B5%B7%E9%9A%90%E5%96%BB/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>博客里应该写什么</title><link>https://blog.coherence.codes/posts/2023/%E5%8D%9A%E5%AE%A2%E9%87%8C%E5%BA%94%E8%AF%A5%E5%86%99%E4%BB%80%E4%B9%88/</link><pubDate>Mon, 24 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/%E5%8D%9A%E5%AE%A2%E9%87%8C%E5%BA%94%E8%AF%A5%E5%86%99%E4%BB%80%E4%B9%88/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/%E5%8D%9A%E5%AE%A2%E9%87%8C%E5%BA%94%E8%AF%A5%E5%86%99%E4%BB%80%E4%B9%88/ -&lt;p>我的 Chrome 有一个插件叫 &lt;a href="https://www.one-tab.com/">Onetab&lt;/a>，本意是用来放一些稍后阅读的标签页。但是稍后阅读这种东西，最终都会转变成垃圾桶，标签越积越多。随着我的几次设备/系统更替（比如从我的老暗影精灵到 deskmini），迁移来迁移去很多上古标签页居然没丢.&lt;/p>
&lt;p>今天在 Onetab 里翻找找到了&lt;a href="https://pureage.info/2014/08/25/hiding-302-using-proxy-pass.html">用 proxy_intercept_errors 和 recursive_error_pages 代理多次 302&lt;/a> 这样一篇文章。文章本身讲的是 nginx 用于反代时如何 follow 上游的 302 的问题，这是一篇普通的技术博客。但是翻看他的博客，却有很多生活随想，日记游记之类的内容。篇幅也长短不一，最短的寥寥一两句话。而翻看我自己的博客，合计三十一篇博文，其中（质量很低的）技术博文占了绝大多数。我不禁有些感慨，写博客究竟是为了什么。是为了在面试时多一个展现自己的方面，还是仅仅是作为一个写作的平台，无所约束地抒发自己的心情？&lt;/p>
&lt;p>还记得我的博客刚搭起来的时候，我写过一篇&lt;a href="https://blog.coherence.codes/posts/2020_and_before/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E4%BA%86%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/">我为什么选择了独立博客&lt;/a>，内容是瞎扯的，但是最后一句话「庞大的互联网中的一方天地」我倒是现在也很认同。&lt;/p>
- https://blog.coherence.codes/posts/2023/%E5%8D%9A%E5%AE%A2%E9%87%8C%E5%BA%94%E8%AF%A5%E5%86%99%E4%BB%80%E4%B9%88/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>IPv6 配置入门</title><link>https://blog.coherence.codes/posts/2023/ipv6-%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8/</link><pubDate>Sun, 16 Apr 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/ipv6-%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/ipv6-%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8/ -&lt;h2 id="背景知识">背景知识&lt;/h2>
&lt;p>&lt;a href="https://datatracker.ietf.org/doc/html/rfc8200">RFC 8200 (Internet Protocol, Version 6 (IPv6) Specification)&lt;/a> 为最新的 IPv6 标准. 主要描述了头部 (Header) 定义, 拓展头部和选项定义等.&lt;/p>
&lt;p>&lt;a href="https://datatracker.ietf.org/doc/html/rfc7084">RFC 7084 (IPv6 CE Router Requirements)&lt;/a> 定义了家用或小型办公室路由器 (IPv6 Customer Edge Routers) 配置的基本要求. OpenWrt 的配置文档遵循了这一 RFC.&lt;/p>
&lt;p>RFC 4861 (IPv6 Neighbor Discovery) 定义了一种网络发现机制, 等效与 IPv4 中的 ARP. 下述的两种机制均依赖于 ND.&lt;/p>
&lt;p>&lt;a href="https://datatracker.ietf.org/doc/html/rfc4862">RFC 4862 (IPv6 Stateless Address Autoconfiguration, SLAAC)&lt;/a> 定义了一种无状态配置地址的机制. &lt;a href="https://datatracker.ietf.org/doc/html/rfc8415">RFC 8415 (Dynamic Host Configuration Protocol for IPv6 (DHCPv6))&lt;/a> 定义了一种配置 IP 地址和前缀的机制. DHCPv6 可以替代 SLAAC 或和 SLAAC 一起工作.&lt;/p>
&lt;p>本文并不是一篇针对 IPv6 的详尽介绍, 而只是对家用 IPv6 配置过程中的一些机制作了阐述.&lt;/p>
&lt;h2 id="术语">术语&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>节点 (node): 一个实现了 IP 协议的设备&lt;/p>
&lt;/li>
&lt;li>
&lt;p>路由器 (router): 一个转发 (不是显式地发给它自己的) IP 包的设备&lt;/p>
&lt;/li>
&lt;li>
&lt;p>主机 (host): 不是路由器的节点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>链路 (link): 一种通信介质, 使节点能够在链路层进行通信. 对于一个 link-only scope 的地址 (即下文中 link-local address), 其只能与在相同链路上的设备通信, 即所谓的在同一个子网内的设备. 这个地址也被称为工作在单链路 (single link) 上. 路由器无法路由这个地址.&lt;/p>
&lt;p>IPv6 CE 路由器是两个网络之间的分割点, 是一个组播域的边界.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="rfc-8200-internet-protocol-version-6-ipv6-specification">RFC 8200 (Internet Protocol, Version 6 (IPv6) Specification)&lt;/h2>
&lt;p>关于分片: 我之前一直以为 IPv6 不能够分片, 然而实际上是 IPv6 包在途中无法分片 (也就是说路由器只能够丢弃过大的包), 分片只发生在主机上.&lt;/p>
&lt;h2 id="rfc-4291-ip-version-6-addressing-architecture">RFC 4291 (IP Version 6 Addressing Architecture)&lt;/h2>
&lt;p>RFC 4291 定义了 IPv6 中的地址空间以及不同的层级. IPv6 必须支持组播, 这样做的好处是主机可以使用一个众所周知的组播地址来和 DHCP 服务器通信. 同时, 在 IPv6 中不存在广播, IPv4 中广播的功能都能够由组播实现.&lt;/p>
&lt;p>一个典型的 IPv6 地址:&lt;/p>
&lt;p>&lt;img src="./ipv6-addr-format-1675603805738-5.png" alt="ipv6-addr-format">&lt;/p>
&lt;p>对于单播和组播地址，它们之间可由不同的网络前缀所辨认:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">地址类型&lt;/th>
&lt;th style="text-align:left">英文名称&lt;/th>
&lt;th style="text-align:left">二进制&lt;/th>
&lt;th style="text-align:left">16进制&lt;/th>
&lt;th style="text-align:left">备注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">链路本地地址&lt;/td>
&lt;td style="text-align:left">Link-local address&lt;/td>
&lt;td style="text-align:left">1111 1110 10&lt;/td>
&lt;td style="text-align:left">fe80::/10&lt;/td>
&lt;td style="text-align:left">单链路通信, 中间 54 bits 为 0, 末尾 64 bits 为 interface ID.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">唯一本地地址&lt;/td>
&lt;td style="text-align:left">Unique local address, ULA&lt;/td>
&lt;td style="text-align:left">1111 1101&lt;/td>
&lt;td style="text-align:left">fd00::/8&lt;/td>
&lt;td style="text-align:left">本地网络通信&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">全局单播地址&lt;/td>
&lt;td style="text-align:left">Global unicast address, GUA&lt;/td>
&lt;td style="text-align:left">001&lt;/td>
&lt;td style="text-align:left">2000::/3&lt;/td>
&lt;td style="text-align:left">互联网通信&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">组播地址&lt;/td>
&lt;td style="text-align:left">Multicast address&lt;/td>
&lt;td style="text-align:left">1111 1111&lt;/td>
&lt;td style="text-align:left">ff00::/8&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>tips: ULA 在 &lt;a href="https://datatracker.ietf.org/doc/html/rfc4193">RFC 4193 (Unique Local IPv6 Unicast Addresses)&lt;/a> 中有详细描述, 其与 link-local address 的主要区别在于 link-local 用于无路由器情况下的链路配置, 以及同一链路下的通信.
ULA 的作用与 IPv4 时代的 10.0.0.0/8 等私有地址类似, 可以用于内网中的服务访问, 其能够被路由, 只是不存在于互联网上,
ULA 用于替代已经 deprecated 的 site-local address.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Note: RFC 4291 似乎规定了一种 Interface Identifiers 的生成方式 Modified EUI-64, 但是我没有细看&lt;/p>
&lt;/blockquote>
&lt;p>一个典型的全局单播地址结构:&lt;/p>
&lt;p>&lt;img src="./ipv6-addr-alloc-1675603832146-7.png" alt="ipv6-addr-alloc">&lt;/p>
&lt;p>一些预定义的 IPv6 组播地址:&lt;/p>
&lt;ul>
&lt;li>本地网段所有节点 (All Nodes Addresses) — ff02::1&lt;/li>
&lt;li>本地网段所有路由器 (All Routers Addresses) — ff02::2
&lt;blockquote>
&lt;p>tips: 这两个地址均为 link-local, interface-local 和 site-local 在这里不作讨论&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>本地请求节点地址 (Solicited-Node Address) — ff02::1:ffxx:xxxx
这个地址由接口的低 24 bits 地址计算得到, 设备必须加入接口相关联的请求节点地址 (无论是自动或手动配置的地址)&lt;/li>
&lt;/ul>
&lt;h2 id="rfc-4861-ipv6-neighbor-discovery">RFC 4861 (IPv6 Neighbor Discovery)&lt;/h2>
&lt;p>RFC 4861 定义了一种网络发现机制 (Neighbor Discovery Protocol, NDP), 等效与 IPv4 中的 ARP. NDP 定义了五种 ICMPv6 (RFC 4443) 消息类型：&lt;/p>
&lt;ol>
&lt;li>路由器请求 (Router Solicitation，简称 RS)&lt;/li>
&lt;li>路由器通告 (Router Advertisement，简称 RA)&lt;/li>
&lt;li>邻居请求 (Neighbor Solicitation)&lt;/li>
&lt;li>邻居通告 (Neighbor Advertisement)&lt;/li>
&lt;li>重定向 (Redirect)&lt;/li>
&lt;/ol>
&lt;h2 id="rfc-4862-ipv6-stateless-address-autoconfiguration">RFC 4862 (IPv6 Stateless Address Autoconfiguration)&lt;/h2>
&lt;p>RFC 4862 定义了一种 IPv6 接口的自动配置机制, 包括生成一个链路本地地址和全局地址, 和一种重复地址检测 (Duplicate address detection) 机制来验证一条链路上地址的唯一性.&lt;/p>
&lt;p>自动配置过程将首先生成链路本地地址. 其由一个链路本地前缀 (RFC 4291 中定义的)+一个接口的标识符 (interface identifier), 当这个地址被分配到一个接口之前, 它是一个暂定地址 (tentative address). 一个节点必须验证它在链路上的唯一性. 具体来说, 节点会发送一个邻居请求报文, 将这个暂定地址作为目标地址. 如果另一个节点正在使用这个地址, 它会返回一个邻居通告来拒绝这个请求. 在验证成功后, 这个地址会成为首选地址 (preferred address).&lt;/p>
&lt;p>接下来主机会广播路由器请求, 以便敦促路由器发送路由器通告. 主机根据路由器通告中的的前缀信息 (Prefix-Infromation) 选项来构造全局地址.&lt;/p>
&lt;blockquote>
&lt;p>Note: 由于 RA 总是会广播给所有主机, 所以 SLAAC 无法做到不给某些主机分配 IP 地址&lt;/p>
&lt;/blockquote>
&lt;p>一个地址的生命周期: 首选地址在首选期限 (preferred lifetime) 过期之后会成为不推荐地址 (deprecated address). 不推荐地址能够继续被用于已经建立的连接中, 但不应该被用于建立新连接. 一个地址在有效期限 (valid lifetime) 过期之后会变为无效地址 (invalid address). 无效地址不能够被用作向外连接的源地址.&lt;/p>
&lt;p>RFC 4862 中并没有规定 interface identifier 是如何产生的, 只说了很多情况下其由接口的链路层地址 (即 MAC 地址) 产生. 这种生成方式会带来一些隐私上的顾虑, 因而在 SLAAC 隐私扩展 (RFC 4941) 中, 主机会生成一个临时地址 (temporary address) 来负责对外通信. 另一种方式是生成一个不变的, 与 MAC 地址无关的 interface identifier, 这种方式在 RFC 7217 中定义.&lt;/p>
&lt;h2 id="rfc-8415-dynamic-host-configuration-protocol-for-ipv6">RFC 8415 (Dynamic Host Configuration Protocol for IPv6)&lt;/h2>
&lt;p>RFC 8415 定义了一个 C/S 协议 DHCPv6, 其功能包括向一个设备提供地址或其他配置, 自动委派 IPv6 前缀等. 当 DHCP 只被用于提供除地址和前缀之外的其他配置 (如 DNS) 时, 它不必维护任何状态, 因此, 这种模式被称为无状态 DHCPv6 (stateless DHCPv6). 与之相对的是有状态 DHCPv6 (stateful DHCPv6). RFC 8415 是一个庞大的 RFC, 废弃了许多之前的 DHCPv6 标准, 如 RFC 3315 (原始的 DHCPv6 标准), RFC 3633 (prefix delegation), RFC 3736 (Stateless Dynamic Host Configuration Protocol (DHCP) Service for IPv6) 等.&lt;/p>
&lt;p>前缀委派 (Prefix Delegation) 用于一个委派路由器 (delegating router) (作为 DHCP 服务器) 向一个请求路由器 (requesting routers) (作为 DHCP 客户端) 委派前缀. 这一机制通常被用于 ISP 向用户委派 (delegate) 一个前缀, 这个前缀将被用于用户网络中的设备.&lt;/p>
&lt;p>&lt;img src="./image-20230410222528623.png" alt="image-20230410222528623">&lt;/p>
&lt;p>DHCP 消息类型 (部分):&lt;/p>
&lt;ul>
&lt;li>Solicit: 客户端发送, 用于定位服务器&lt;/li>
&lt;li>Advertise: 服务器发送, 对于 solicit 的回复&lt;/li>
&lt;li>Request: 客户端发送: 用于请求配置&lt;/li>
&lt;li>Reply: 服务器发送, 包含租约和其他配置, 是对于 Solicit, Request, Renew, 或 Rebind 的回复&lt;/li>
&lt;/ul>
&lt;h2 id="pmtu-问题">PMTU 问题&lt;/h2>
&lt;p>在配置 IPv6 的过程中一个常见的问题是 PMTU 问题. Path MTU Discovery (PMTUD) 是确定 MTU 的一种标准方式, 在 &lt;a href="https://datatracker.ietf.org/doc/html/rfc8201">RFC 8201 (Path MTU Discovery for IP version 6)&lt;/a> 中定义. RFC 中这样描述:&lt;/p>
&lt;blockquote>
&lt;p>Nodes not implementing Path MTU Discovery must use the IPv6 minimum link MTU defined in [RFC8200] as the maximum packet size.&lt;/p>
&lt;/blockquote>
&lt;p>从中我们可以推测 PMTUD 在 (几乎) 所有节点上无需配置默认启用.&lt;/p>
&lt;p>PMTUD 工作方式为源节点首先选择下一跳的 MTU (已知) 作为 PMTU. 如果传输路径上的某个节点因为包过大而无法转发一个包, 它就会丢弃这个包并返回一条 ICMPv6 Packet Too Big 消息.&lt;/p>
&lt;p>&lt;img src="./image-20230416142554039.png" alt="image-20230416142554039">&lt;/p>
&lt;p>(图源 &lt;a href="https://datatracker.ietf.org/doc/html/rfc4443#section-3.2">RFC 4443&lt;/a>, 最小的 IPv6 MTU 即 1280 字节)&lt;/p>
&lt;p>收到消息后源节点根据 ICMPv6 消息中的 MTU 字段减少 PMTU. 这一过程会重复直到源节点估计的 PMTU 小于真正的 PMTU.&lt;/p>
&lt;p>这一机制带来的问题是, 如果某个路由器没有发送 ICMPv6 消息或是 ICMPv6 消息被路由器的防火墙 block 了, 那么实现了 PMTUD 的节点可能会遇到连接问题. 比如 TCP 的三次握手成功, 但在数据传输的时候 hang 住了. 这种情况被称为黑洞连接.&lt;/p>
&lt;p>一个 PMTUD 的扩展在 &lt;a href="https://datatracker.ietf.org/doc/html/rfc4821">RFC 4821 (Packetization Layer Path MTU Discovery)&lt;/a> 中定义, 其不依赖 ICMPv6 消息.&lt;/p>
&lt;p>个人猜测在 IPv4 下这个问题比较少见的原因是 IPv4 支持在路由器上进行分片.&lt;/p>
&lt;h3 id="一个例子">一个例子&lt;/h3>
&lt;p>在访问淘宝时, 淘宝会访问 &lt;code>g.alicdn.com&lt;/code> 这一域名, 即 &lt;code>2408:8670:af0:9:3::3e3&lt;/code> 这个 IP. 在 TCP 握手的时候 MSS Option 被设置成了 1440 Bytes, 即 MTU 为以太网的 MTU 1500 (1440 + TCP Header 20 + IPv6 Header 40). 可以看到在第 1353 个包的时候 Wireshark 指示了 &amp;ldquo;TCP Previous Segment Not Captured&amp;rdquo;, 猜测序号 1352 和 1353 之间的某些服务器发送的包被丢了.&lt;/p>
&lt;p>&lt;img src="./image-20230412235736591.png" alt="image-20230412235736591">&lt;/p>
&lt;p>下面来看正确处理的情况, 访问 &lt;a href="https://test-ipv6.com/">Test IPv6&lt;/a> 时, 有一项测试为 &amp;ldquo;Test IPv6 large packet&amp;rdquo;, 测试内容为访问一个 MTU 为 1280 的服务器. 通过抓包发现 TCP 握手时的 MSS 仍为 1440, 但在第 862 个包的时候我发送了一个过大的包, 于是在第 864 个包我的路由器 (由于运行了 PPPOE, MTU 为 1492) 返回了一个 ICMPv6 报文, 于是在第 865 个包我重传了这个包, 把 MTU 减少到了 1492, 这一过程不断重复直到 MTU 被设置为 1280.&lt;/p>
&lt;p>&lt;img src="./image-20230417221041457.png" alt="image-20230417221041457">&lt;/p>
&lt;blockquote>
&lt;p>Note: 这里需要&lt;a href="https://wiki.wireshark.org/CaptureSetup/Offloading">关闭 TCP Segmentation Offload&lt;/a>, 否则包长度会显示为超过 MTU, 这是因为 TCP 包的分片被 Offload 到了网卡以减轻主机 CPU 的负担.&lt;/p>
&lt;/blockquote>
&lt;p>在仅 IPv4 的情况下访问 &lt;code>g.alicdn.com&lt;/code>, 可以发现服务端发送的几个包发生了分片:&lt;/p>
&lt;p>&lt;img src="./image-20230416141447823.png" alt="image-20230416141447823">&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;ul>
&lt;li>一个典型的 IPv4 路由器会使用 NAT, 因此默认阻止所有入站连接, 其通常使用 UPnP 来开放某一端口. 而 IPv6 不使用 NAT, 因此正确配置防火墙是必要的.&lt;/li>
&lt;li>&lt;a href="https://datatracker.ietf.org/doc/html/rfc4389">RFC 4389 (Neighbor Discovery Proxies (ND Proxy))&lt;/a>, 可以作为一种在 ISP 不支持 DHCPv6-PD 情况下使用 IPv6 的一种方式. 虽然该 RFC 的分类是 experimental, 但其已经被广泛实现了.&lt;/li>
&lt;/ul>
&lt;h2 id="参见">参见&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://openwrt.org/docs/guide-user/network/ipv6/configuration">OpenWrt IPv6 configuration&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.packetmania.net/2020/12/01/IPv6-Addressing/">IPv6动态地址分配机制详解&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wiki.archlinux.org/title/IPv6">ArchWiki IPv6&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.apnic.net/2016/05/19/fragmenting-ipv6/">Fragmenting IPv6&lt;/a> 讨论了和分片有关的问题, 包括 UDP 下的处理&lt;/li>
&lt;li>&lt;a href="https://www.v2ex.com/t/800024">开启 IPv6 后网速变得很慢？可能是 PMTU 黑洞的问题 - V2EX&lt;/a>&lt;/li>
&lt;/ul>
- https://blog.coherence.codes/posts/2023/ipv6-%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>Hello, Hugo!</title><link>https://blog.coherence.codes/posts/2022/hello_hugo/</link><pubDate>Sun, 02 Oct 2022 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2022/hello_hugo/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2022/hello_hugo/ -&lt;p>这是一个船新的博客！&lt;/p>
&lt;h2 id="历史">历史&lt;/h2>
&lt;p>在大二（2018）的时候，我萌生了搭建一个自己的独立博客的想法，于是就有了 &lt;a href="https://blog.coherence.codes/posts/2020_and_before/hexo%E6%90%AD%E5%BB%BA%E5%B0%8F%E8%AE%B0/">hexo搭建小记&lt;/a>，当时我随手一找找到的基本都是 Hexo，于是我就用了。引用一段当时写的关于页面：&lt;/p>
&lt;blockquote>
&lt;h2 id="关于博客">关于博客&lt;/h2>
&lt;ul>
&lt;li>2021-02-08 迁移到 pelican, 打算自己写个主题, 待填坑&lt;/li>
&lt;li>2020-03-26 更新 Hexo 至 4.2.0，启用 hexo-generator-sitemap 插件&lt;/li>
&lt;li>2020-02-22 更改评论为 &lt;code>disqusjs&lt;/code>，详见作者的&lt;a href="https://blog.skk.moe/post/disqusjs/">博文&lt;/a>；启用 &lt;a href="https://github.com/theme-next/theme-next-pjax">pjax&lt;/a>&lt;/li>
&lt;li>2019-12-24 启用新域名&lt;code>blog.coherence.codes&lt;/code>&lt;/li>
&lt;li>2019-10-07 升级主题至 Next V7.4.1&lt;/li>
&lt;li>2018-09-24 第一篇博文。采用 Hexo + NexT 主题， 部署于 Github Pages。搭建过程见{% post_link Hexo搭建小记 这篇文章 %}&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>Next 就是一个非常大众的主题，有几种变体，我用的是一个叫 &lt;code>pisces&lt;/code> 的变体，长这样（原博客图已经找不到了，只能用官方 Demo 凑数了）：&lt;/p>
&lt;p>&lt;img src="image-20221002165030564.png" alt="image-20221002165030564">&lt;/p>
&lt;p>这一时期的博客位于 &lt;a href="https://github.com/cjc7373/cjc7373.github.io/tree/source/source">source 分支&lt;/a>，最后更新于 2020-04-16。&lt;/p>
&lt;p>由于这个主题实在是太大众了，中途（2019-10 左右）我也想过换一个主题（&lt;a href="https://github.com/yscoder/hexo-theme-indigo">hexo-theme-indigo&lt;/a>，一个 Material Design 风格的主题），但是没有配置成功，&lt;a href="https://github.com/cjc7373/cjc7373.github.io/tree/theme-indigo">theme-indigo 分支&lt;/a>便是那次尝试。theme-indigo 的效果图长这样：&lt;/p>
&lt;p>&lt;img src="image-20221002165819783.png" alt="image-20221002165819783">&lt;/p>
&lt;p>到了 21 年 2 月，我开始重新调研博客生成器，当时看到了一个 Python 写的 Pelican，而我又希望壮大一下 Python 生态，于是就用了。用了之后发现并没有什么合适的主题，恰巧 Pelican 用的模板引擎 Jinja 和 Django Template Engine 很像，我比较熟悉，于是我就想自己写一个主题，然而这一工作从没开始过.. 于是我现在的博客是这样的（&lt;del>极简主义&lt;/del>）：&lt;/p>
&lt;p>&lt;img src="image-20221002171314620.png" alt="image-20221002171314620">&lt;/p>
&lt;p>这段时间里我还写过一个&lt;a href="https://github.com/cjc7373/pelican-markdown-image">处理图片的 Pelican 插件&lt;/a>，虽然现在看起来挺蠢的..&lt;/p>
&lt;p>再后来，我又对 Rust 产生了兴趣，于是又发现了 Zola，这时候我找到了 &lt;a href="https://github.com/AmazingRise/hugo-theme-diary">hugo-theme-diary&lt;/a> 这个主题，感觉非常不错。这个主题是从 &lt;a href="https://byvoid.com/zhs/">BYVoid&lt;/a> 那看来的，好看，有响应式，也有文章内目录。于是就想把它移植到 zola，在 port 了一个 head 之后，这个计划就被无限期搁置了。&lt;/p>
&lt;p>终于，我感觉还是有必要有一个好看的博客的，于是我最终选择了 Hugo+hugo-theme-diary，加上一点点自己的魔改。&lt;/p>
&lt;h2 id="迁移">迁移&lt;/h2>
&lt;p>Hugo 对于资源文件的处理有&lt;a href="https://gohugo.io/content-management/image-processing/">自己的一套规则&lt;/a>，即博客文章位于 &lt;code>posts/post_name/index.md&lt;/code>，这篇文章资源文件放在 &lt;code>posts/post_name/&lt;/code> 这个路径下面。而我原来的文件结构为文章位于 &lt;code>posts/post_name.md&lt;/code>，资源文件位于 &lt;code>posts/post_name/&lt;/code>。所以我不得不写了一个脚本来迁移图片：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> pathlib &lt;span style="color:#f92672">import&lt;/span> Path
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> re
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>md_image &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>compile(&lt;span style="color:#e6db74">r&lt;/span>&lt;span style="color:#e6db74">&amp;#34;!\[(.*)\]\((.*)\)&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">replace_image_reference_in_a_md_file&lt;/span>(md, dry_run&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">False&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(md, &lt;span style="color:#e6db74">&amp;#34;r&amp;#34;&lt;/span>, encoding&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;utf8&amp;#34;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> content &lt;span style="color:#f92672">=&lt;/span> f&lt;span style="color:#f92672">.&lt;/span>read()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">replace&lt;/span>(&lt;span style="color:#66d9ef">match&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> match[0]: all matched string
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> match[1]: name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> match[2]: image path
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rep &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#34;![&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>match[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">](./&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>match[&lt;span style="color:#ae81ff">2&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">&amp;#39;/&amp;#39;&lt;/span>)[&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Replacing &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>match[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> with &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>rep&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> rep
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> content &lt;span style="color:#f92672">=&lt;/span> md_image&lt;span style="color:#f92672">.&lt;/span>sub(replace, content)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">not&lt;/span> dry_run:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(md, &lt;span style="color:#e6db74">&amp;#34;w&amp;#34;&lt;/span>, encoding&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;utf8&amp;#34;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f&lt;span style="color:#f92672">.&lt;/span>write(content)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>to_mig: list[Path] &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>working_dir &lt;span style="color:#f92672">=&lt;/span> Path(&lt;span style="color:#e6db74">&amp;#34;./2022&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> working_dir&lt;span style="color:#f92672">.&lt;/span>iterdir():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> f&lt;span style="color:#f92672">.&lt;/span>suffix &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;.md&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> to_mig&lt;span style="color:#f92672">.&lt;/span>append(f)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>print(to_mig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> f &lt;span style="color:#f92672">in&lt;/span> to_mig:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> replace_image_reference_in_a_md_file(f)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f&lt;span style="color:#f92672">.&lt;/span>rename(working_dir &lt;span style="color:#f92672">/&lt;/span> Path(f&lt;span style="color:#f92672">.&lt;/span>stem) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#e6db74">&amp;#34;index.md&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># print(f&amp;#34;Move {f} to {Path(f.stem) / &amp;#39;index.md&amp;#39;}&amp;#34;)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hugo 用的模板引擎是 Go 标准库里的，这点好评，Helm 用的同样是这个模板引擎。&lt;/p>
&lt;h2 id="部署">部署&lt;/h2>
&lt;p>现在的部署简单好多啊，只需一个配置文件，Github Actions 因为是自家产品的缘故连 token 都不需要了，自定义域名 CNAME 也只需在配置文件中增加一行，相比于三年之前的部署体验真的是天差地别..&lt;/p>
&lt;h2 id="一些问题">一些问题&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Hugo 处理页面之间链接也有&lt;a href="https://gohugo.io/content-management/cross-references/">自己的规则&lt;/a>，需要转换，不过我好像也没什么跨页面链接&lt;/p>
&lt;/li>
&lt;li>
&lt;p>代码高亮的配色非常诡异..&lt;/p>
&lt;p>&lt;img src="image-20221003005014257.png" alt="image-20221003005014257">&lt;/p>
&lt;p>发现在本地的配色是正常的，检查发现本地是 Hugo extended version，于是在 actions 中也启用了 extended 后恢复正常，挺奇怪的..&lt;/p>
&lt;/li>
&lt;/ul>
- https://blog.coherence.codes/posts/2022/hello_hugo/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item></channel></rss>