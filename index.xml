<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Coherence's Blog</title><link>https://blog.coherence.codes/</link><description>Recent content on Coherence's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</copyright><lastBuildDate>Sun, 24 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.coherence.codes/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenWrt 搭建透明代理</title><link>https://blog.coherence.codes/posts/2024/openwrt_transparent_proxy/</link><pubDate>Sun, 24 Nov 2024 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2024/openwrt_transparent_proxy/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2024/openwrt_transparent_proxy/ -&lt;p>openclash、shellclash 之类的方案感觉都太复杂了。我的需求只是给 chromecast 用上代理，并且在代理失效时不要影响局域网中的其他设备。所以想找一个简单的方案。&lt;/p>
&lt;p>经过一番摸索，发现 Macvlan 很适合我，具体步骤如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>创建一个 macvlan 设备&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-openwrt" data-lang="openwrt">config device
option type &amp;#39;macvlan&amp;#39;
option ifname &amp;#39;br-lan&amp;#39;
option mode &amp;#39;bridge&amp;#39;
option name &amp;#39;br-lanmac0&amp;#39;
option ipv6 &amp;#39;1&amp;#39;
&lt;/code>&lt;/pre>&lt;p>注意这里需要选择启用 ipv6，否则 br-lan 不会下发 RA，导致局域网内设备没有 v6 地址，具体原因还不清楚。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建一个接口绑定到这个设备&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-openwrt" data-lang="openwrt">config interface &amp;#39;clash&amp;#39;
option proto &amp;#39;static&amp;#39;
option device &amp;#39;br-lanmac0&amp;#39;
option ipaddr &amp;#39;192.168.2.2&amp;#39;
option netmask &amp;#39;255.255.255.0&amp;#39;
option gateway &amp;#39;192.168.2.1&amp;#39;
option defaultroute &amp;#39;0&amp;#39;
&lt;/code>&lt;/pre>&lt;p>IP 地址分配一个在局域网段下的，网关填 lan 地址。注意关闭默认路由，否则会把 PPPoE 的路由给删了，导致局域网内设备连不上网，具体原因也不清楚。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把这个接口添加到防火墙的 lan zone 中，否则 lan 发给该接口的包会被丢弃&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下载 mihomo （原 clash-meta）二进制，配置 tun 绑定到之前的设备上&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tun&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enable&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">stack&lt;/span>: &lt;span style="color:#ae81ff">system&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">auto-route&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">auto-redirect&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">include-interface&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">br-lanmac0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>写入 init 脚本到 &lt;code>/etc/init.d/clash&lt;/code>，以便开机自启&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/sh /etc/rc.common
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>START&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">99&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>start&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> export HOME&lt;span style="color:#f92672">=&lt;/span>/root
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nohup /root/clash/clash &amp;gt; /root/clash/log.txt &amp;amp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># commands to launch application&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>stop&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># commands to kill application &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> killall clash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启用脚本 &lt;code>/etc/init.d/clash enable&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在需要代理的设备上指定网关为 &lt;code>192.168.2.2&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>然后，就没有然后了。它工作！具体为什么能工作呢，咱也不知道&amp;hellip;&lt;/p>
- https://blog.coherence.codes/posts/2024/openwrt_transparent_proxy/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>Linux 内存管理初探</title><link>https://blog.coherence.codes/posts/2024/linux_memory_management/</link><pubDate>Thu, 05 Sep 2024 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2024/linux_memory_management/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2024/linux_memory_management/ -&lt;p>本文试图解释两个简单的问题：&lt;code>free&lt;/code> 命令中的 used/free/available 等字段究竟代表了什么？而 &lt;code>ps&lt;/code> 命令中的 VSZ/RSS 又代表了什么？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ free -h
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total used free shared buff/cache available
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Mem: 38Gi 15Gi 834Mi 3.3Gi 25Gi 22Gi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Swap: 19Gi 5.3Gi 14Gi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ps aux --sort&lt;span style="color:#f92672">=&lt;/span>-rss | head -5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cjc &lt;span style="color:#ae81ff">3354&lt;/span> 2.3 4.6 &lt;span style="color:#ae81ff">97222056&lt;/span> &lt;span style="color:#ae81ff">1917888&lt;/span> ? Ssl Oct07 37:42 /usr/bin/qbittorrent
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cjc &lt;span style="color:#ae81ff">354324&lt;/span> 1.3 2.7 &lt;span style="color:#ae81ff">2772076&lt;/span> &lt;span style="color:#ae81ff">1137784&lt;/span> ? Ssl 12:05 1:59 /usr/bin/telegram-desktop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cjc &lt;span style="color:#ae81ff">2806&lt;/span> 6.6 2.3 &lt;span style="color:#ae81ff">4141220&lt;/span> &lt;span style="color:#ae81ff">941484&lt;/span> ? Sl Oct07 109:17 /usr/bin/kwin_wayland ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cjc &lt;span style="color:#ae81ff">3390&lt;/span> 1.5 1.9 &lt;span style="color:#ae81ff">3994932&lt;/span> &lt;span style="color:#ae81ff">792364&lt;/span> ? Sl Oct07 26:10 /usr/lib/zotero/zotero-bin ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本文假定读者具有虚拟内存的基础知识，文中的代码将以 C 语言为例。&lt;/p>
&lt;h2 id="从虚拟内存开始说起">从虚拟内存开始说起&lt;/h2>
&lt;p>我们先来复习一下虚拟内存地址转换的流程。&lt;/p>
&lt;p>&lt;img src="./image-20240905013733596.png" alt="image-20240905013733596">
（图源：CSAPP)&lt;/p>
&lt;p>当程序访问一个虚拟地址时，在汇编层面体现为一条读指令（&lt;code>mov&lt;/code> 之类的），由 CPU 中的 MMU 处理地址转换。MMU（Memory Management Unit）首先根据页表基址寄存器（Page Table Base Register, PTBR）的地址加上虚拟地址的页面偏移（也就是虚拟地址的前 x 位）找到页表条目（Page Table Entry, PTE）的地址（这里省略了 TLB 的部分），这个地址当然是物理地址。PTE 中存储了这一页的物理地址，以及标记该页是否在内存中的有效位。如果该页存在内存，那么 CPU 直接访问内存进行读取。如果不存在，则进入缺页异常（page fault）程序，程序由用户态进入内核态。此时程序可能会被阻塞并换出，直到页被读入内存。&lt;/p>
&lt;p>这里我们就要问了，为什么一个页会不在内存呢？在 Linux 中，存在两种情况：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>这一页是匿名内存（anonymous memory），它们通常是程序运行时动态分配的内存（比如 C 中的 &lt;code>malloc&lt;/code> 函数）。它们没有文件后备，但如果系统中启用了 swap 交换文件，那么它们也能被换出到 swap 中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这一页是 page cache，也就是文件内存（file memory），它们可能是代码（比如 &lt;code>.text&lt;/code> 段）或缓存的数据（比如通过 mmap 映射的文件，mmap 是个非常重要的系统调用，下面还会提到）。它们是文件后备的（backed by file），所以能够被换出，或者也被称为回收（reclaim）。&lt;/p>
&lt;p>这里其实还能再细分一下，如果这一页是未修改过的（clean），那么可以直接修改页表有效位，不需要其他操作。如果是修改过的页面（dirty），则需要先将变更写入磁盘后才能回收。（为什么会存在脏页？请看下文）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="page-cache">Page Cache&lt;/h2>
&lt;p>那我们为什么需要 Page Cache呢？&lt;a href="https://web.archive.org/web/20221222014954/https://manybutfinite.com/post/page-cache-the-affair-between-memory-and-files/">Page Cache, the Affair Between Memory and Files&lt;/a> 这篇非常精彩的文章讲述了 Page Cache。当操作系统开始处理文件时，会碰到两个问题：&lt;/p>
&lt;ul>
&lt;li>读写磁盘相比于读写内存慢了好几个数量级&lt;/li>
&lt;li>对于一些文件（比如代码和共享库），需要只载入一次，而在多个进程之间共享&lt;/li>
&lt;/ul>
&lt;p>而这两个问题都能被 page cache 解决。正如其名，page cache 就是内核存储的按页大小分割的文件。操作系统将文件缓存在内存中，解决了第一个问题。对于能够共享的文件，操作系统在内存中只存储一份副本，解决了第二个问题。常规的文件读写都会通过 page cache 进行。&lt;/p>
&lt;p>那是不是文件只会存储在 page cache 中呢？当我们读取一个文件时，需要：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>malloc()&lt;/code> 分配一块堆内存作为缓冲区，假设为 4K。这块内存是匿名内存。&lt;/li>
&lt;li>使用 &lt;code>open()&lt;/code> 打开一个文件获取文件描述符，使用 &lt;code>read()&lt;/code> 读取文件到缓冲区。此时内核将读取一个页大小的文件内容存放到 page cache 中，再把 page cache 的内容复制到程序的堆内存上。&lt;/li>
&lt;/ul>
&lt;p>看到问题了吗？一份数据在内存中存了两份！解决这个问题的方式是内存映射文件（Memory-mapped files）。在 Linux 上也就是 &lt;code>mmap&lt;/code> 系统调用。mmap 的流程如下：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>mmap()&lt;/code> 将一个文件映射到虚拟地址空间中的某一段地址，长度为用户给定。&lt;/li>
&lt;li>直接读取这段地址中的某一个。&lt;/li>
&lt;li>触发常规访存流程。也就是说，如果这个地址所在的页不在内存中，则触发缺页中断把这个页读进内存。&lt;/li>
&lt;/ul>
&lt;p>因为 page cache 的存在，对文件的写入（&lt;code>write()&lt;/code> 系统调用）不会马上写入到磁盘。内核会把修改写入到 page cache 中，同时把该页标记为脏（dirty），因此文件写入不会阻塞。&lt;/p>
&lt;p>由于脏页的存在，Linux 需要处理文件（在内存/磁盘中）的一致性。存在两种实现文件一致性的方法：&lt;/p>
&lt;ul>
&lt;li>Write Through（直写/写穿）：对文件的写入会直接写到磁盘。这是通过 &lt;code>fsync&lt;/code>, &lt;code>fdatasync&lt;/code> 等系统调用实现的。&lt;/li>
&lt;li>Write back（写回）：对文件的写入暂存在内存。系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块。这是 Linux 的默认行为。&lt;/li>
&lt;/ul>
&lt;p>我们能做个小实验验证这个行为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat /proc/meminfo | grep Dirty &lt;span style="color:#75715e"># 查看当前脏页大小&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Dirty: &lt;span style="color:#ae81ff">828&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ dd &lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">=&lt;/span>/dev/zero of&lt;span style="color:#f92672">=&lt;/span>testfile.txt bs&lt;span style="color:#f92672">=&lt;/span>1M count&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10+0 records in
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10+0 records out
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">10485760&lt;/span> bytes &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span> MB, &lt;span style="color:#ae81ff">10&lt;/span> MiB&lt;span style="color:#f92672">)&lt;/span> copied, 0.00600495 s, 1.7 GB/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cat /proc/meminfo | grep Dirty &lt;span style="color:#75715e"># 此时对文件的写入只存在 page cache 中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Dirty: &lt;span style="color:#ae81ff">10596&lt;/span> kB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sync &lt;span style="color:#75715e"># 刷脏&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cat /proc/meminfo | grep Dirty
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Dirty: &lt;span style="color:#ae81ff">364&lt;/span> kB
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，上文提到了“常规”的文件读写是通过 page cache 进行的，通过在 &lt;code>open()&lt;/code> 时使用 &lt;code>O_DIRECT&lt;/code> 选项等方法能够绕过 page cache。这就是所谓的 Direct IO，一些数据库会采取这种方法进行 IO，以获取更高的性能。&lt;/p>
&lt;p>一个文件映射可以是私有（private）或者共享（shared）的。&lt;/p>
&lt;ul>
&lt;li>更新一个共享的文件映射对其他进程可见，同时也会更新到其映射的文件上。&lt;/li>
&lt;li>更新一个私有的文件映射同理，不对其他进程可见，也不会更新到其映射的文件上。&lt;/li>
&lt;/ul>
&lt;p>那如果有两个进程同时映射了一个文件，并且使用了私有映射，这个文件是不是就要在内存中存两份了？当然不会。内核使用了 CoW（copy on write，写时复制）来解决这一问题。&lt;/p>
&lt;p>&lt;img src="./copyOnWrite.png" alt="The Copy-On-Write mechanism">
（图源：&lt;a href="https://web.archive.org/web/20221222014954/https://manybutfinite.com/post/page-cache-the-affair-between-memory-and-files/">Page Cache, the Affair Between Memory and Files&lt;/a>）&lt;/p>
&lt;p>&lt;code>render&lt;/code> 和 &lt;code>render3d&lt;/code> 两个进程私有地 map 了相同的文件，这些页被内核标记成只读（事实上，只读标记并不意味着它们是&lt;strong>只读&lt;/strong>的，只是为了区分它们和非 CoW 的页）。&lt;code>render&lt;/code> 进程随后修改了一部分文件，由于只读标记的存在，程序访存时将触发 page fault，内核将该页复制一份成为匿名页（因为私有的文件映射并不会实际更新到文件中），并修改页表将原先的虚拟地址指向新的匿名页。随后对该匿名页进行写入。这一机制对应用程序完全透明。&lt;/p>
&lt;p>这一技术也被用在 fork 一个进程时。&lt;/p>
&lt;h2 id="vszrss">VSZ/RSS&lt;/h2>
&lt;p>有了上面的基础知识，就可以说说 VSZ/RSS 了。查询 &lt;code>man top&lt;/code> （top 的手册解释得比 ps 更详细）可知：&lt;/p>
&lt;ul>
&lt;li>VSZ（virtual memory size，虚拟内存大小），或 VIRT（virtual），程序所申请的内存大小。&lt;/li>
&lt;li>RSS （resident set size，常驻集大小？我也不知道怎么翻译），或 RES（resident memory size）进程实际占用的物理内存，也就是那些未被换出的页的大小。&lt;/li>
&lt;/ul>
&lt;p>我们有时候能够见到 VSZ 远大于 RSS，比如这堆申请了几十G内存的 chromium：&lt;/p>
&lt;p>&lt;img src="./image-20241012005445767.png" alt="image-20241012005445767">&lt;/p>
&lt;p>这是因为内核使用了惰性分配（lazy allocation），也就是程序请求内存分配的时候，只分配虚拟地址。程序第一次访问虚拟地址的时候，才分配物理内存。这种做法进一步提高了系统的内存利用率。&lt;/p>
&lt;p>更进一步，Linux 采取了超额分配（overcommit）的方式，也就是程序申请的内存可以大于物理内存+swap 的总数。与之相对，Windows 则并不允许 overcommit，所有程序申请的总内存必须小于物理内存+swap 的总数。&lt;/p>
&lt;p>需要注意的是，RSS 并不能代表程序“需要”的内存，RSS 很大可能仅仅是系统的内存水位不高，不需要的页尚未被回收。比如设想一下一个程序 mmap 了一个 40G 大小的文件，全部读取并进行了一些操作。由于程序之后可能还会用到这个文件，这段内存并没有被 munmap。此时程序的 RSS 为 40G，但是程序可能很久都不会用到这 40G。&lt;/p>
&lt;p>另一个能够反映程序内存占用的指标是 WSS（working set size，工作集大小），也就是一段时间内（比如 10min）程序使用的内存大小。Linux 并没有提供一个很简单的方式读取进程的 WSS，但是使用一些工具能做到这一点，参照&lt;a href="https://www.brendangregg.com/blog/2018-01-17/measure-working-set-size.html">这篇文章&lt;/a>。&lt;/p>
&lt;p>上面说到 fork 时内核使用了 CoW，我们可以做一个小实验观察这一点：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">size_t&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">1024&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">1024&lt;/span> &lt;span style="color:#f92672">*&lt;/span> (&lt;span style="color:#66d9ef">size_t&lt;/span>)&lt;span style="color:#ae81ff">1024&lt;/span>; &lt;span style="color:#75715e">// 10G
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ptr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">malloc&lt;/span>(size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// use 10G memory
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">memset&lt;/span>(ptr, &lt;span style="color:#ae81ff">0&lt;/span>, size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> pid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fork&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pid &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do not fork again
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">sleep&lt;/span>(&lt;span style="color:#ae81ff">100&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="./image-20240905021713812.png" alt="image-20240905021713812">&lt;/p>
&lt;p>可以看到每个 fork 出来的进程的 RSS 都是 10G，而我的系统并没有 100G 内存。这也从侧面说明了简单将 RSS 相加统计系统的内存用量是不可靠的。&lt;/p>
&lt;p>除了 ps/top，有没有办法能够获得更细节的进程内存信息呢？当然是有的。这就是 &lt;code>/proc/&amp;lt;pid&amp;gt;/maps&lt;/code> 和 &lt;code>/proc/&amp;lt;pid&amp;gt;/smaps&lt;/code>。smaps 相比比 maps 包含了更详细的信息。通过一个&lt;a href="https://github.com/cjc7373/my_scripts/blob/master/active/parse_proc_smaps.py">简单的 Python 脚本&lt;/a>就可以对 smaps 中的信息进行汇总。&lt;/p>
&lt;p>比如看一下 qbittorrent 的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ python parse_proc_smaps.py /proc/2179/smaps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">========================================================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Private_Clean Private_Dirty Shared_Clean Shared_Dirty Rss Pss VSZ library
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">========================================================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">36360&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">36360&lt;/span> kB &lt;span style="color:#ae81ff">36360&lt;/span> kB &lt;span style="color:#ae81ff">2274188&lt;/span> kB &lt;span style="color:#f92672">[&lt;/span>anonymous&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">39536&lt;/span> kB &lt;span style="color:#ae81ff">39536&lt;/span> kB &lt;span style="color:#ae81ff">19768&lt;/span> kB &lt;span style="color:#ae81ff">39536&lt;/span> kB /memfd:wayland-shm &lt;span style="color:#f92672">(&lt;/span>deleted&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">18464&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">18464&lt;/span> kB &lt;span style="color:#ae81ff">18464&lt;/span> kB &lt;span style="color:#ae81ff">18508&lt;/span> kB &lt;span style="color:#f92672">[&lt;/span>heap&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">4764&lt;/span> kB anon_inode:i915.gem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">128&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">128&lt;/span> kB &lt;span style="color:#ae81ff">128&lt;/span> kB &lt;span style="color:#ae81ff">132&lt;/span> kB &lt;span style="color:#f92672">[&lt;/span>stack&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">8&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">8&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">8&lt;/span> kB &lt;span style="color:#f92672">[&lt;/span>vdso&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">16&lt;/span> kB &lt;span style="color:#f92672">[&lt;/span>vvar&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">4&lt;/span> kB &lt;span style="color:#f92672">[&lt;/span>vsyscall&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">========================================================================================================================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2087680&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">2087680&lt;/span> kB &lt;span style="color:#ae81ff">2087680&lt;/span> kB &lt;span style="color:#ae81ff">60184244&lt;/span> kB /mnt/gloway/TV_Series
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">51900&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">51900&lt;/span> kB &lt;span style="color:#ae81ff">51900&lt;/span> kB &lt;span style="color:#ae81ff">5558576&lt;/span> kB /mnt/gloway/Documentary
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">52&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">52&lt;/span> kB &lt;span style="color:#ae81ff">52&lt;/span> kB &lt;span style="color:#ae81ff">5302412&lt;/span> kB /mnt/gloway/Movies
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2988&lt;/span> kB &lt;span style="color:#ae81ff">7664&lt;/span> kB &lt;span style="color:#ae81ff">62508&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">73160&lt;/span> kB &lt;span style="color:#ae81ff">13477&lt;/span> kB &lt;span style="color:#ae81ff">366556&lt;/span> kB /usr/lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">19636&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">19636&lt;/span> kB &lt;span style="color:#ae81ff">676&lt;/span> kB &lt;span style="color:#ae81ff">20236&lt;/span> kB /usr/share/fonts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1440&lt;/span> kB &lt;span style="color:#ae81ff">164&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">1604&lt;/span> kB &lt;span style="color:#ae81ff">1604&lt;/span> kB &lt;span style="color:#ae81ff">12584&lt;/span> kB /usr/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">4096&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">4096&lt;/span> kB &lt;span style="color:#ae81ff">54&lt;/span> kB &lt;span style="color:#ae81ff">6080&lt;/span> kB /usr/lib/locale
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">1976&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">1976&lt;/span> kB &lt;span style="color:#ae81ff">69&lt;/span> kB &lt;span style="color:#ae81ff">3260&lt;/span> kB /home/cjc/.cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">32&lt;/span> kB &lt;span style="color:#ae81ff">248&lt;/span> kB &lt;span style="color:#ae81ff">1308&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">1588&lt;/span> kB &lt;span style="color:#ae81ff">414&lt;/span> kB &lt;span style="color:#ae81ff">2176&lt;/span> kB /usr/lib/qt6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">52&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">544&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">596&lt;/span> kB &lt;span style="color:#ae81ff">269&lt;/span> kB &lt;span style="color:#ae81ff">1212&lt;/span> kB /usr/share/icons
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">444&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">444&lt;/span> kB &lt;span style="color:#ae81ff">16&lt;/span> kB &lt;span style="color:#ae81ff">448&lt;/span> kB /var/cache/fontconfig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">80&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">80&lt;/span> kB &lt;span style="color:#ae81ff">3&lt;/span> kB &lt;span style="color:#ae81ff">184&lt;/span> kB /usr/share/mime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">8&lt;/span> kB &lt;span style="color:#ae81ff">36&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">44&lt;/span> kB &lt;span style="color:#ae81ff">8&lt;/span> kB &lt;span style="color:#ae81ff">60&lt;/span> kB /usr/lib/libproxy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">28&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">28&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">28&lt;/span> kB /usr/lib/gconv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">24&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">24&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">24&lt;/span> kB /usr/share/locale
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">12&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">12&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">12&lt;/span> kB /home/cjc/.local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">12&lt;/span> kB /usr/share/qt6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">0&lt;/span> kB &lt;span style="color:#ae81ff">4&lt;/span> kB /var/lib/flatpak
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2144144&lt;/span> kB &lt;span style="color:#ae81ff">63036&lt;/span> kB &lt;span style="color:#ae81ff">90700&lt;/span> kB &lt;span style="color:#ae81ff">39536&lt;/span> kB &lt;span style="color:#ae81ff">2337416&lt;/span> kB &lt;span style="color:#ae81ff">2230942&lt;/span> kB &lt;span style="color:#ae81ff">73795264&lt;/span> kB total
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里有一个新概念 PSS（proportional set size），对于每个 RSS 中的页，如果这个页被 n 个进程共享，那么在计算时就把它除以 n。也就是说，如果有一个库 RSS 100k，但是它被 10 个进程共享，那么每个进程的 PSS 就是 10k。&lt;/p>
&lt;p>表中的第二部分展示了内存中文件映射的部分。从中可以看到，qb 的 2.3G RSS 有 2.1G 都是做种的文件（&lt;code>/mnt/gloway&lt;/code>），&lt;code>/usr/lib&lt;/code> 中的库文件占了 73M，但是由于共享的进程较多，PSS 只有 13M。&lt;/p>
&lt;p>第一部分主要是堆栈的内存。&lt;code>[heap]&lt;/code> 和 &lt;code>[anonymous]&lt;/code> 实际都是堆内存（也就是通过 malloc 分配的匿名页面），&lt;/p>
&lt;h2 id="free">free&lt;/h2>
&lt;p>那么 free 里的内存占用是怎么计算出来的呢？简单查阅 &lt;code>man free&lt;/code> 可知，其数据来源于 &lt;code>/proc/meminfo&lt;/code>（&lt;a href="https://github.com/torvalds/linux/blob/master/Documentation/filesystems/proc.rst#meminfo">内核文档&lt;/a>），含义如下：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>total：物理内存/swap 的总数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>used：total - available&lt;/p>
&lt;/li>
&lt;li>
&lt;p>free：未使用的内存&lt;/p>
&lt;/li>
&lt;li>
&lt;p>cache/buffer：page cache&lt;/p>
&lt;ul>
&lt;li>
&lt;blockquote>
&lt;p>As of the 2.4 kernel, these two caches have been combined. Today, there is only one cache, the Page Cache
&lt;a href="https://www.thomas-krenn.com/en/wiki/Linux_Page_Cache_Basics">https://www.thomas-krenn.com/en/wiki/Linux_Page_Cache_Basics&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>available：对还有多少可用内存的估计。这个字段考虑了系统需要部分 page cache 来工作，并且不是所有可回收的 slab 是可回收的（由于正在被使用的项目）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这里就是一个反直觉的地方了。内核对可用内存的计算仅仅是一个&lt;strong>估计&lt;/strong>，内核并不知道确切的“可用”内存的数量。&lt;/p>
&lt;p>在深究之前我们先来说一说内存的水位（watermark）和&lt;a href="https://docs.kernel.org/admin-guide/mm/concepts.html#reclaim">回收&lt;/a>。内核把物理内存空间分成多个 Zone，Zone 之间的区别在这里并不重要，可以简单理解为物理内存是所有 Zone 相加。一个 Zone 内的页面除了已用内存页，剩下的就是空闲页（free pages）。空闲页范围中有三个水位线（watermark ）评估当前内存压力情况，分别是高位（high）、低位（low）、最小位（min）。&lt;/p>
&lt;p>如果空闲页面在 low 水位之上，内核什么也不会干。当空闲页低于 low 水位后，内核会唤醒 &lt;code>kswapd&lt;/code> 线程。它会异步扫描内存页进行内存回收，直到水位达到 high。如果内存用量进一步升高，空闲页面低于 min 水位，此时内存分配将进入直接回收（direct reclaim）。回收操作将变为同步的，内存分配操作将阻塞直到足够多的页面被回收。&lt;/p>
&lt;p>&lt;img src="./640.webp" alt="Image">
（图源：&lt;a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649785631&amp;amp;idx=1&amp;amp;sn=4ff0a18db034174b5dec2455c759e3d8">Linux内存变低会发生什么问题-腾讯技术工程&lt;/a>)&lt;/p>
&lt;p>内核的内存回收采取 LRU 算法。当然，有时候程序会比内核有更多的信息，知道哪些页不应该被换出，这时程序可以使用 &lt;code>mlock&lt;/code> 等系统调用阻止某些页被换出。&lt;/p>
&lt;p>实践上，内核的内存水位设定非常保守。我们可以通过 &lt;code>/proc/zoneinfo&lt;/code> 计算得到。在我的 40G 内存的机器上面：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat /proc/zoneinfo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Node 0, zone DMA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pages free &lt;span style="color:#ae81ff">262&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> boost &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min &lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low &lt;span style="color:#ae81ff">9&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> high &lt;span style="color:#ae81ff">12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spanned &lt;span style="color:#ae81ff">4095&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> present &lt;span style="color:#ae81ff">3998&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> managed &lt;span style="color:#ae81ff">3840&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Node 0, zone DMA32
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pages free &lt;span style="color:#ae81ff">212504&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> boost &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min &lt;span style="color:#ae81ff">621&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low &lt;span style="color:#ae81ff">996&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> high &lt;span style="color:#ae81ff">1371&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spanned &lt;span style="color:#ae81ff">1044480&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> present &lt;span style="color:#ae81ff">395943&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> managed &lt;span style="color:#ae81ff">379492&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Node 0, zone Normal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pages free &lt;span style="color:#ae81ff">1503321&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> boost &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> min &lt;span style="color:#ae81ff">16267&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> low &lt;span style="color:#ae81ff">26089&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> high &lt;span style="color:#ae81ff">35911&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> spanned &lt;span style="color:#ae81ff">10024960&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> present &lt;span style="color:#ae81ff">10024960&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> managed &lt;span style="color:#ae81ff">9824396&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>将三个 Zone 的水位相加（单位为页，大小 4KB）：&lt;/p>
&lt;ul>
&lt;li>min = 6+621+16267 = 66 MB&lt;/li>
&lt;li>low = 9+996+26089 = 106 MB&lt;/li>
&lt;li>high = 12+1371+35911 = 145 MB&lt;/li>
&lt;/ul>
&lt;p>可以看到相比于内存总数几乎可以忽略不计。回到可用内存，我们来看一眼&lt;a href="https://elixir.bootlin.com/linux/v6.11.3/source/mm/show_mem.c#L32">计算 available 的代码&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">long&lt;/span> available;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> pagecache;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> wmark_low &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> reclaimable;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> zone &lt;span style="color:#f92672">*&lt;/span>zone;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这里就是上文的计算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">for_each_zone&lt;/span>(zone)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wmark_low &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#a6e22e">low_wmark_pages&lt;/span>(zone);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Estimate the amount of memory available for userspace allocations,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * without causing swapping or OOM.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 空闲的页
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>available &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">global_zone_page_state&lt;/span>(NR_FREE_PAGES) &lt;span style="color:#f92672">-&lt;/span> totalreserve_pages;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Not all the page cache can be freed, otherwise the system will
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * start swapping or thrashing. Assume at least half of the page
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * cache, or the low watermark worth of cache, needs to stay.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pagecache &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">global_node_page_state&lt;/span>(NR_ACTIVE_FILE) &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">global_node_page_state&lt;/span>(NR_INACTIVE_FILE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 加上 page cache, 减去 low 水位的预留
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>pagecache &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#a6e22e">min&lt;/span>(pagecache &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>, wmark_low);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>available &lt;span style="color:#f92672">+=&lt;/span> pagecache;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Part of the reclaimable slab and other kernel memory consists of
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * items that are in use, and cannot be freed. Cap this estimate at the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * low watermark.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 再加上内核中的可回收页
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>reclaimable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">global_node_page_state_pages&lt;/span>(NR_SLAB_RECLAIMABLE_B) &lt;span style="color:#f92672">+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">global_node_page_state&lt;/span>(NR_KERNEL_MISC_RECLAIMABLE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>reclaimable &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#a6e22e">min&lt;/span>(reclaimable &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>, wmark_low);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>available &lt;span style="color:#f92672">+=&lt;/span> reclaimable;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (available &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> available &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> available;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于大内存的机器，由于 low 水位几乎可以忽略，所以 available 约等于空闲的页 + page cache。&lt;/p>
&lt;h2 id="swap">swap&lt;/h2>
&lt;p>swap 并不是所谓的“紧急”内存，只有在物理内存不够时才会使用。如上文所说，swap 的意义在于让匿名内存可以被回收。操作系统总是倾向于用满物理内存，可能有的匿名页很久都不会被使用（比最久的 page cache 还久），那么它们就应当被换出到 swap 中。&lt;/p>
&lt;p>内核参数中的 &lt;code>vm.swappiness&lt;/code> 控制在内存回收的时候，是优先回收匿名页面， 还是优先回收文件页面。这个值越高, 回收回收匿名页面的倾向越高。&lt;/p>
&lt;h2 id="windows">Windows&lt;/h2>
&lt;p>Linux 已经讲得够多了，那么 Windows 又是怎样的呢？其实&lt;a href="https://www.zhihu.com/question/43714216/answer/1164044678">大差不差&lt;/a>。只是 Windows 中没有 overcommit，进程申请的内存总和不能超过物理内存+swap。&lt;/p>
&lt;p>另外扯一下 WSL。由于 WSL 2 是虚拟机，而 Linux 内核又倾向于使用尽量多的内存，导致分配给 WSL 的内存会被吃满，空闲的内存（page cache 占据的部分）没法返还给 Windows。终于在 2023 年的某次更新中，WSL 引入了&lt;a href="https://devblogs.microsoft.com/commandline/windows-subsystem-for-linux-september-2023-update/#automatic-memory-reclaim">autoReclaimMemory&lt;/a>，在 WSL 认为系统空闲后，会通过 cgroup 的 memory.reclaim 功能回收内存。&lt;/p>
&lt;h2 id="小故事">小故事&lt;/h2>
&lt;ul>
&lt;li>在高速网络下，网络协议栈占用的内存可能会很可观。我同学碰到过在一个只有 500M 内存的机器上搭梯子，然后一跑测速梯子就会被 OOM Kill，最后排查出来是 tcp 的发送/接受缓存占用的内存太多。调了一下 &lt;code>net.ipv4.tcp_wmem&lt;/code> 和 &lt;code>net.ipv4.tcp_rmem&lt;/code> 就好了。&lt;/li>
&lt;/ul>
&lt;h2 id="ref">ref&lt;/h2>
&lt;ul>
&lt;li>fc 老师的两篇关于 &lt;a href="https://farseerfc.me/zhs/in-defence-of-swap.html">swap&lt;/a> 的&lt;a href="https://farseerfc.me/zhs/followup-about-swap.html">文章&lt;/a>是我的内存管理启蒙&lt;/li>
&lt;li>&lt;a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649787834&amp;amp;idx=1&amp;amp;sn=c62c1e183a2663ac5ab369d191e50519">K8s里我的容器到底用了多少内存？&lt;/a>，这篇文章中提到了 k8s 中的几个内存指标&lt;/li>
&lt;/ul>
- https://blog.coherence.codes/posts/2024/linux_memory_management/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>日本之旅</title><link>https://blog.coherence.codes/posts/2024/japan_trip/</link><pubDate>Wed, 24 Apr 2024 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2024/japan_trip/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2024/japan_trip/ -&lt;h2 id="计划">计划&lt;/h2>
&lt;p>我和 Moo 一开始说的是去新马泰，后来改为日本，真正开始做攻略已经是三月下旬了。日本只支持旅行社送签，我在 3/26 申请了签证并提交了材料，4/3 出签，花了六个工作日，还是挺快的。&lt;/p>
&lt;p>&lt;img src="./image-20240424004023270.png" alt="image-20240424004023270">&lt;/p>
&lt;p>订机票和酒店的时候差不多离出发还有半个月，这时候的价格已经挺贵了，可能提前两三个月订会更便宜。初步的计划是东京-&amp;gt;京都-&amp;gt;大阪，详细的计划写在 hackmd 上。实际上我们的计划并不详细，只是提前订了 Tokyo Skytree、Shibuya sky 的票，规定了一下在东京的那几天每天在哪个区域活动，而在京都和大阪的行程则完全没有计划，全靠临时起意。&lt;/p>
&lt;p>我在出发前半个月用多邻国速成了两周日语，非常失败，五十音都没认全，还是只能用英语交流。结论为不如用 Anki 认五十音。&lt;/p>
&lt;h2 id="流水账">流水账&lt;/h2>
&lt;h3 id="413">4/13&lt;/h3>
&lt;p>终于踏上了去东京的旅程，虽然很怕在途中突然被要求改论文/交材料，but be it，放心玩，越玩越稳。&lt;/p>
&lt;p>我是先到杭州东，坐&lt;a href="https://zh.wikipedia.org/zh-cn/%E5%A4%8D%E5%85%B4%E5%8F%B7CR200J%E5%9E%8B%E5%8A%A8%E8%BD%A6%E7%BB%84">垃圾桶&lt;/a>去上海南，再坐地铁去浦东机场，这套流程也太长了，我上午十点出发，三点半才到浦东机场。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240424004456080.png" width="500px">
&lt;/figure>
（来点经典小红书照片）&lt;/p>
&lt;p>Moo 买的是西安-&amp;gt;上海浦东-&amp;gt;东京成田的中转航班，第二段和我是同一个航班，本来的计划是浦东机场会合。然而不幸的是当天西安有雷雨天气，第一段航班延误了大概两个小时，导致赶不上第二段航班，只能改签。日本的手机卡是 Moo 买的，由于 Moo 延误了，一个问题就是我在日本的第一天没有网。下飞机了发现我的电信卡没有国际漫游。有的话用一天 25，其实可以接受，但是我的卡已经没信号收不了短信了，只能微信喊我爸问了下客服，说是要换卡才能开通？这是什么操作。于是只能去便利店高价（880 日元的卡费 + 1300 日元三天的套餐费）买了张卡。&lt;/p>
&lt;p>出关的时候排队排了好久，大概有半个多小时，很多人可能是填的纸质材料比较慢，我填了 Visit Japan Web 感觉就半分钟就办完了。本来我们在线买的两张 Skyliner 票，只要凭兑换二维码兑换车票就行，然而现在就我一个人，和 staff 交流了半天，最后的办法是退我们网上买的票，然后重新分别买。本打算顺便买交通卡的，但是卖卡的地方（不知道有没有别的地方，我问到的应该是在 Skyliner &amp;amp; Keisai Information Center）十点关门了，于是没买到。&lt;/p>
&lt;p>到达第一天的青旅的时候已经过十一点了，被加收了 1000 日元 late check-in fee。入住的时候我说这是我第一次来日本，前台小哥特地说了一句“Welcome to Japan”。住的是十四人间（！），但是大家都挺安静的，只是晚上和早上在 lobby 都没见着什么人，没有交流。青旅建在铁路正下方，列车驶过的声音还挺大的。不过这地段是相当好啊，就在天空树旁边。&lt;/p>
&lt;p>&lt;img src="./image-20240424015124861.png" alt="image-20240424015124861">&lt;/p>
&lt;p>（Wise Owl Hostels 就是我住的青旅，上面就是铁路）&lt;/p>
&lt;h3 id="414">4/14&lt;/h3>
&lt;p>Moo 中午才到，于是我上午按计划去了上野。到了上野先看国立西洋美术馆的特展，主题是 Does the Future Sleep Here? 每个章节配有&lt;a href="https://www.nmwa.go.jp/qrcode/exhibitions/intro/index_zh.html">中文文字说明&lt;/a>，国际化做得不错。我没想到这个展有那么多内容，到十二点半了才看完。还有一段脱衣舞影片，我看不懂，但我大受震撼.jpg&lt;/p>
&lt;p>看完去吃饭，Google Maps 搜了个蛋包饭，发现在 JR 上野站付费区里，于是买了张最便宜的票（150 日元）进去了，发现这家店要排队，于是换了家店，一碗非常普通的面要 900 日元。吃完出站，发现在自动售货机退不了款，于是亏了 150。
吃完饭继续看美术馆的常设展，看完 Moo 到了。&lt;/p>
&lt;p>&lt;img src="./image-20240424010133135.png" alt="image-20240424010133135">&lt;/p>
&lt;p>（这张图很符合我对美术馆的印象）&lt;/p>
&lt;p>然后我们在上野公园和周边走了走，其实那是应该走到东京大学的，但是当时没想到。然后去秋叶原，逛了几个模型店，还有个卖动漫周边的，Moo 买了个二次元周边。晚饭在秋叶原随机挑了家店解决，tabelog 3 分，我只能给一分，牛肉煎得非常老，两个人 5000 日元，也不划算。&lt;/p>
&lt;p>这天和之后的两天住的是一个在中野区的民宿，一个非常小的两层小楼。但是居住体验相当不错。位置也很好，离地铁站步行一分钟。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240424015829970.png" width="500px">
&lt;/figure>
&lt;h3 id="415">4/15&lt;/h3>
&lt;p>早上先去买交通卡，跑到 seibu-shinjuku 站买 pasmo 卡，被告知因为缺货无法出售，并建议我们去旁边的 JR East 旅客服务中心买 suica，我还担心没带护照能不能买到（welcome suica 只卖给外国人）。到了发现门口贴了张本店不出售 welcome suica 卡，但是到都到了就进去问问呗，一问发现居然卖普通 suica 卡，于是购入两张。&lt;/p>
&lt;p>买完在 shinjuku 街头闲逛，喝了杯咖啡，中午去台场，逛了一下一个商场，然后吃了个炸牛排饭，比昨天晚上的那个要好不少。吃完看了看门口的高达，然后在海滨公园走了走，公园里有人工沙滩，没什么人。本来是打算乘船去上野的，走过了一个没什么人的码头，后来才发现最后一班船的时间已经过了，于是只能乘地铁去上野。&lt;/p>
&lt;p>去上野看浅草寺，门口那个商店街和国内的景区差不多，花 100 日元求了个签。然后去天空树，看东京的夜景。&lt;/p>
&lt;p>&lt;img src="./image-20240424224740647.png" alt="image-20240424224740647">&lt;/p>
&lt;p>（Tokyo Tower！）&lt;/p>
&lt;p>晚饭吃マクドナルド（我已经改不回来了.jpg）。吃完饭大概九点多，还早，于是去 shinjuku 逛了逛，去的是歌舞伎町，看到了非常多的“无料案内所”，应该是拉皮条的，具体是不是真的嫖娼就不知道了。Moo 拍了一下某家店的招牌，就有个人上来搭话，问 &amp;ldquo;Are you looking for massages?&amp;quot;，事后想想这应该就是皮条客了，按摩估计也不是正经按摩。还看到了一个非常乱的广场，垃圾随地乱扔，许多人躺在广场上，很难想象这是东京。小红书上说这里很多是不良少年。这个广场令人害怕，赶紧走了。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240424220720972.png" width="500px">
&lt;/figure>
&lt;h3 id="416">4/16&lt;/h3>
&lt;p>早上去 Shibuya Sky，其实就是楼顶的一个平台，昨天看了夜景今天看日景。小红书建议买黄昏的票看日落，然而我们当时买的时候已经没有黄昏的票了。&lt;/p>
&lt;p>&lt;img src="./image-20240424224520667.png" alt="image-20240424224520667">&lt;/p>
&lt;p>（经典打卡地 Shibuya Scramble Crossing，这时人不是很多，后来我们在晚上再路过的时候人是真的多）&lt;/p>
&lt;p>中午吃了乌冬面，那家店能够俯瞰 Shibuya 的街道，位置非常好。然后去逛了逛唐吉柯德，我反正是没啥购物的欲望。整个日本之旅只买了六张明信片。晚上仍然在 Shibuya，Google Maps 找了一家评分高一点的店，吃了个鲑鱼定食。日本的所有定食（套餐）都会附赠味增汤，然而味增汤并不好喝。&lt;/p>
&lt;p>吃完饭去了家卖唱片的店，很大，有七八层。如今卖 CD 和黑胶还能开这么大的店真是不多见了。&lt;/p>
&lt;h3 id="417">4/17&lt;/h3>
&lt;p>Moo 要去丰乡小学圣地巡礼（&lt;del>傻逼二次元&lt;/del>），所以今天的我们先乘坐东海道新干线从东京站到米原站。先在东京站吃了个午饭，汉堡肉拌饭，听着比较黑暗吃着还行。我们买的票是非指定席当日票，车上的人并不是很多，我们这个车厢可能就坐满了三分之一。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240427014338589.png" width="600px">
&lt;/figure>
&lt;p>新干线的票价由里程票+特急券组成，刚买到的时候看到这两部分还以为买错了。&lt;/p>
&lt;p>到米原后换乘近江铁道前往丰乡站，这车是我坐过的最晃的火车了，两节车厢，全车就一个司机，还是手工检票，非常落后。&lt;/p>
&lt;p>&lt;img src="./image-20240424223442375.png" alt="image-20240424223442375">&lt;/p>
&lt;p>（车看着还挺新的）&lt;/p>
&lt;p>米原是始发站，可能因为这天是工作日，在始发站上车时车上就我们两个人，让人非常怀疑这家公司什么时候倒闭。好在过了几站之后人就变多了，这时是三点多已经有高中生放学了，真早啊！Moo 还搭讪了一个女生，问她是不是已经放学了。我们都不会日语，怎么问呢？当然是用 Google 翻译了！打字翻译成日语然后给她看。她说今天放学有点早，同样用 Google 翻译打字给我们看。可惜 Moo 就搭讪了这一句，没有然后了。&lt;/p>
&lt;p>&lt;img src="./image-20240424223637578.png" alt="image-20240424223637578">&lt;/p>
&lt;p>（空无一人的车厢）&lt;/p>
&lt;p>&lt;img src="./image-20240427000708227.png" alt="image-20240427000708227">&lt;/p>
&lt;p>（还有车头视角）&lt;/p>
&lt;p>差不多五点我们离开丰乡，回米原站拿寄存的行李，然后去京都。丰乡站没有工作人员，也没有售票口，怎么买票呢？问了一个黑人老哥，老哥非常热情，详细地解释了买票的流程，英语也非常标准，几乎没有口音。他说他在车站等他的妻子，在我们上车时他还给我们指了取票机的位置。这列车买票的方式是上车时取一张乘车券（写有当前的站名），然后看车上的显示屏根据上下车站计算车费，下车时把车费和乘车券交给乘务员，太原始了！&lt;/p>
&lt;p>到了米原是晚饭时间了，于是又 Google Maps 找了家店，然后发现这家店只有日语菜单！只能全凭 Google 翻译加上意会了。吃了天妇罗，一碗豆腐加牛肉，炸猪排，还有个很黑暗的大葱天妇罗。&lt;/p>
&lt;p>到了京都 check-in 青旅然后睡觉。&lt;/p>
&lt;h3 id="418">4/18&lt;/h3>
&lt;p>早上八点起床吃早饭，青旅提供免费早餐，但是只有面包。&lt;/p>
&lt;p>本来想买个京都 one day pass 的，发现能租自行车，于是租了一辆，京都和东京一样全城禁止停车，只能停在自行车停车场。京都确实很小，感觉自行车能够一个小时绕一圈。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240425020955481.png" width="500px">
&lt;/figure>
&lt;p>（这自行车还是光头窄胎，非常好骑）&lt;/p>
&lt;p>瞎骑了一通后前往清水寺，找纸质地图上标的停车点没找到，绕了一大圈。看了一下租车时发的 rules 那张纸，发现有个 Google Maps 自制停车地图（就是在 Google Maps 上标点），发现之前其实已经快到了。停好车已经十二点了，吃了个炸鸡当午饭。&lt;/p>
&lt;p>清水寺人非常多，仿佛回到了国内。有好多中学生，看着像在春游。买票走了一圈，求了个签，很怀疑都是吉。看挂的写心愿的牌牌的时候看到了一个希望 ETH 和 BTC 大涨的，太抽象了，你应该去求赛博佛祖.jpg&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240425020740639.png" width="500px">
&lt;/figure>
&lt;p>出去之后买个了抹茶冰激凌，确实味道不太一样，很好吃。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240425020428117.png" width="400px">
&lt;/figure>
&lt;p>然后前往任天堂总部，发现就是两座楼，没啥好看的。然后前往京都铁道博物馆，我们到的时候已经四点了，五点闭馆，博物馆里有很多真的火车，科普也做得非常好，比如演示铁轨的原理。可惜只有一个小时来不及看。&lt;/p>
&lt;p>&lt;img src="./image-20240427012131252.png" alt="image-20240427012131252">&lt;/p>
&lt;p>（这好像是初代新干线）&lt;/p>
&lt;p>自行车五点半还车，日本人下班真早.jpg 晚上去吃一个米其林餐厅，去了一看给了个号预计七点二十吃上，于是去找了个咖啡厅吃了点小吃。这家米其林餐厅卖的是拉面，味道不错，但也没有特别惊艳。在大阪的时候我居然在一家书店的米其林指南里找到了这家店，很妙。&lt;/p>
&lt;p>回到青旅后大厅有一桌子人在聊天，桌子上有一个德国男生，毕业工作了一年半后辞职出来旅行，中途还去面了个试；一个以色列男生，好像是在法国还是哪里上学，Gap 出来旅行；一个东京女生；两个加拿大人，岁数感觉有四十多了；一个台湾退休大爷；一个墨西哥人。我：阿巴阿巴。我很想加入进去但是口语太差，只能大部分时间听他们聊。台湾大爷讲了好多个笑话，简直是笑话大师。话题基本围绕着语言、每个人去过的地方和家乡展开。&lt;/p>
&lt;h3 id="419">4/19&lt;/h3>
&lt;p>早上在青旅吃早饭的时候碰到了昨天的台湾大爷，还有他的妻子。他们已经退休了，然后就到处旅游，这次来日本是报了一个语言学校学习日语，台湾可以免签逗留 90 天，所以他们的学习时长是两个月。他们很能聊，瞎扯了一堆。说自己的经历，问我的专业，说互联网公司的就业，说大陆的房价太高了，夸赞蒋经国搞好了台湾经济，又批评民进党把两岸关系搞得很差，又说现在台湾的年轻人已经对大陆没有感情了。那个阿姨的爷爷是苏州人在解放前迁往台湾的，她还会说两句苏州话“铜田”、“困觉”，非常妙。&lt;/p>
&lt;p>吃完饭 checkout 后前往大阪，乘坐 Hankyu-Kyoto Line，在 Awaji Station 换乘 Hankyu-Senri Line，实际上我并没有看到 Hankyu-Senri Line，只要是开往天下茶屋（Tengachaya）方向的列车都可以坐，虽然 Google Maps 上标了两条线但是不用换乘。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240425024800801.png" width="400px">
&lt;/figure>
&lt;p>（注意 &amp;ldquo;Continue on the same vehicle&amp;rdquo;）&lt;/p>
&lt;p>相比于京都和东京，大阪简直是自由美利坚，地上随处可见烟头，人们在禁烟标志下吸烟，特别是在道顿堀那块，垃圾随处可见，太自由了。我们先去酒店放了行李，中午在 7-11 吃盒饭。&lt;/p>
&lt;p>下午去中之岛，有几栋比较有特色的建筑，但也没有什么特别的看点。走到一个美术馆，看到有莫奈的展，于是进去看了一波。我的学生证居然还能买学生票。之前在国立西洋美术馆就买了两张莫奈的明信片，到这里又买了两张。这个展的国际化一般，很多画旁边只有日语写的说明，我只能借助 Google 翻译了。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240427002837125.png" width="400px">
&lt;/figure>
&lt;p>（The Manneporte near Etretat）&lt;/p>
&lt;p>然后去天王寺，在天王寺公园的草地上躺了会，看了会日落。吃旁边商场买的中华料理——饺子。&lt;/p>
&lt;p>&lt;img src="./image-20240427003130229.png" alt="image-20240427003130229">&lt;/p>
&lt;p>晚上去道顿堀，感觉并不好看。路上看到了许许多多的居酒屋，大阪人是真爱喝酒。&lt;/p>
&lt;h3 id="420">4/20&lt;/h3>
&lt;p>今天没啥意思。商场感觉都一个样，本来想去坐坐阪堺电车的，感觉 Moo 不是很感兴趣，也没坐成。早上睡得比较晚，起床十一点了，就在 7-11 吃了早饭，然后去梅田，梅田感觉和道顿堀一样，都是商店街。Moo 在 7-11 买到了一个面包夹炒面，感觉非常黑暗。晚饭吃了个肯德基。&lt;/p>
&lt;p>晚上去看了场脱衣舞（全裸！），门票 4500 日元，观众全是老大爷，还有一些游客。感觉也没啥意思，看得我都快睡着了。形式大概是表演一段，然后和观众打个招呼，收收小费。观众们给小费的挺多的，这些 stripper 感觉都很懂，面向一个方向的观众打招呼的时候都会特意露一下。&lt;/p>
&lt;p>总体评价今天还不如在酒店看东京爱情故事。&lt;/p>
&lt;p>&lt;img src="./image-20240427004442952.png" alt="image-20240427004442952">&lt;/p>
&lt;p>（酒店的电视）&lt;/p>
&lt;h3 id="421">4/21&lt;/h3>
&lt;p>今天踏上归途了，实际上今天和 4/13 都没有玩的部分，所以日本之旅去头去尾也就七天。今天是起床就出发去机场了。去机场坐的是 Nankai-Limited Express，Google Maps 上写的是坐一列特急的班次。站台上有个特急券售票机，我还在想需不需要买特急券。恰好正在买票的一个女生也是中国人（因为她选的语言是中文），正好问了一下，结果是需要的。但是可能太临近发车时间了，并没有买到（这辆车是全列指定席）。于是只能坐了下一班急行的列车。&lt;/p>
&lt;p>机场里在过了海关和安检后有一堆免税店，据我在登机口的观察一大半的人都在免税店买了东西。免税店卖烟酒、零食、化妆品。然而 Moo 查了下发现化妆品其实并不比天猫国际更便宜。中华烟倒是比国内便宜，很神奇，如果买了是不是一种出口转内销呢。&lt;/p>
&lt;p>&lt;img src="./image-20240427004646676.png" alt="image-20240427004646676">&lt;/p>
&lt;p>下午两点顺利返程。出机场的时候居然还看到了火山引擎的的巨幅广告，现在的云厂商都已经这么卷了吗。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240427005636862.png" width="400px">
&lt;/figure>
&lt;h2 id="铁路">铁路&lt;/h2>
&lt;p>日本的铁路系统和国内很不一样，首先它的地铁和铁路没有严格的区分，很多铁路都是横排座位，也就是地铁座位的常见布局。即使是纵排座位的列车，也大多是非指定席，我只见到东海道新干线的某几节车厢和大阪南海电铁特急列车是指定席。这就导致了比如在东京，我们的地铁通票（Tokyo Metro + Toei Subway）实际上并不能覆盖所有的公共交通，很多时候 Google Maps 会让我们坐 JR 山手线或者某个私铁。&lt;/p>
&lt;p>其次铁路和车站非常密集，几乎随处可见铁轨、道口和轰隆隆行驶的列车。道口（日本称踏切）特有的铛铛-铛铛的提示声非常有感觉。&lt;/p>
&lt;p>&lt;img src="./image-20240424215305194.png" alt="image-20240424215305194">&lt;/p>
&lt;p>（大阪天王寺附近的一个道口）&lt;/p>
&lt;p>&lt;img src="./image-20240427020407790.png" alt="image-20240427020407790">&lt;/p>
&lt;p>（东京台场附近的一列车）&lt;/p>
&lt;p>&lt;img src="./image-20240427021228647.png" alt="image-20240427021228647">&lt;/p>
&lt;p>（大阪梅田附近的一条铁路）&lt;/p>
&lt;p>第一次坐 toei subway 的线路时感觉非常迷惑，地铁居然还分车的类型？还开往不同的终点站？一列车还能同时运行在两条线路上（即&lt;a href="https://zh.wikipedia.org/zh-cn/%E7%9B%B4%E9%80%9A%E9%81%8B%E8%A1%8C">贯通运营&lt;/a>）？到后来就习惯了。&lt;/p>
&lt;p>&lt;img src="./image-20240424014310226.png" alt="image-20240424014310226">&lt;/p>
&lt;p>日本每条线路都会有一个或两个英文字母的编号，每个站有个数字编号，所以看 Google Maps 的时候只需要看比如乘坐 T(Tozai Line) T02-&amp;gt;T03 换乘 JY(Yamanote Line) 到 JY20，而不需要去记站名了。但是 Google Maps 只对东京市内铁路有这个提示，其他铁路只会写线路编号，而没有站名编号了。&lt;/p>
&lt;p>常开式的闸机也是好文明！就在不久前，&lt;a href="https://mp.weixin.qq.com/s/iR9kZtepYqPwEkyct5NWCg">上海地铁也开始试点&lt;/a>这种模式了，真就学习国外先进经验了。&lt;/p>
&lt;p>&lt;img src="./image-20240424014502291.png" alt="image-20240424014502291">&lt;/p>
&lt;p>（浅草附近的一个车站）&lt;/p>
&lt;p>在山手线上还看到了一起事故，地铁飞人.jpg 网上查了查好像京王线的事故数量挺多的..&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240424010948892.png" width="600px">
&lt;/figure>
&lt;p>（山手线列车的显示屏）&lt;/p>
&lt;p>另外每个站几乎都有列车的时刻表，而且基本都很准时，守时的日本人.jpg 每个站也基本都有各站的楼梯、卫生间等设施图。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240425023357637.png" width="500px">
&lt;/figure>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240425023234136.png" width="500px">
&lt;/figure>
&lt;p>在日本，你几乎能完全依靠公共交通，而且基本都是铁路。我们没有坐过公交车和出租车。在东京，基本上方圆一公里之内必有一个车站（当然，这可能只是市区的情况）。&lt;/p>
&lt;h2 id="其他感受">其他感受&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>日本人真有礼貌，动不动就すみません（私密马赛）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>水很贵，一瓶 100-140 日元不等，但是 7-11 里 2L 的水也是 100 日元，就很奇怪。见到的最便宜的饮料是 80 日元的罐装咖啡，比水都便宜。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>语言方面，碰到的大部分人会简单的英语。也有英语比较好的，比如成田机场 skyliner 售票处、JR East 旅客服务中心和那位黑人老哥。东京第一晚青旅的前台小哥英文也很好，不过他看上去不是日本人。餐厅点餐、便利店买东西用英文进行简单的交流基本都没问题，当然还有另一种选择，那就是 Google 翻译。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这次旅行基本都在看城市，下次还有机会去日本的话想去看看国家公园之类的地方，爬一爬富士山。七天的时间还是有点赶的，像在青旅的那桌人，基本都是一个月或者好几个月出来旅游。而在中国这种感觉不太现实，毕业成为社畜之后更难有大段的空闲时间了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这次旅行共计花费 9k 不到一点，机票占了 30%，酒店也差不多，剩下的是吃饭和景点门票。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;figure>&lt;img src="https://blog.coherence.codes/posts/2024/japan_trip/image-20240427023038805.png" width="400px">
&lt;/figure>
&lt;p>出发前我换了 4w 日元，到了日本后 Moo 又换了 4w 日元。几乎任何一个便利店都会有个 ATM 机以供取钱，在 7-11 取钱的时候好像会收十几块的手续费，走 JCB 的渠道购汇。剩下的消费靠信用卡。&lt;/p>
&lt;p>Suica 或者其他交通卡非常通用，几乎哪都能用。只是少数地方是 cash-only，不过我们在大阪见到的很多自动售货机都是 cash-only，比较落后。支付宝微信的普及度也很高，基本上能刷卡的地方就能用支付宝微信。&lt;/p>
&lt;p>&lt;img src="./image-20240427023828844.png" alt="image-20240427023828844">&lt;/p>
&lt;p>（7-11 门口贴的支付方式一览）&lt;/p>
&lt;p>在米原吃饭的时候，Moo 想用微信支付结账，店员还操作了好一会（他们那块牌牌上写了支持微信支付），显然是第一次用（&lt;del>有种县城小饭店刷信用卡的感觉&lt;/del>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关于垃圾分类，日本的垃圾分类感觉没有一个统一的标准，每个城市甚至每个行政区都有细微的差别。另一个直观的感受是在街上见不到垃圾桶，能见到的也是只能扔瓶子的垃圾桶，到最后我们的垃圾基本只能去便利店扔。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关于无障碍设施，我们在东京的街头看到了很多独自出行的残疾人，包括坐在轮椅上的人和盲人，这在国内基本上是看不见的。基本上每个红绿灯都有无障碍提示音设备，也没有见过盲道被占用的情况。&lt;/p>
&lt;/li>
&lt;/ul>
- https://blog.coherence.codes/posts/2024/japan_trip/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>Go 包管理（一）入门和设计原则</title><link>https://blog.coherence.codes/posts/2024/go_pkg_mgmt_1_toturial/</link><pubDate>Sat, 06 Jan 2024 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2024/go_pkg_mgmt_1_toturial/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2024/go_pkg_mgmt_1_toturial/ -&lt;p>在我初学 Go 的时候，曾被网上的过时教程和各种对 &lt;code>$GOPATH&lt;/code> 的操作搞得云里雾里，而现在我们已经基本用不到 &lt;code>$GOPATH&lt;/code> 了，因为在 2023 年， Go Modules 已经一统天下了。但是在这之前，是群魔乱舞的时代，对这段历史感兴趣的同学可以参考&lt;a href="https://blog.wolfogre.com/posts/golang-package-history/">这篇博客&lt;/a>。&lt;/p>
&lt;p>顺便提一下，GOPATH 时代包没有“版本”的概念，这可能是因为 Google 内部采用 monorepo 的方式（即所有代码都放在一个仓库中）管理代码，所有人都基于 HEAD 来 build，所以当有人的改动 break 了其他人的代码时，很容易在 build 时反映出来。Go 作者之一 Rob Pike 的文章 &lt;a href="https://commandcenter.blogspot.com/2024/01/what-we-got-right-what-we-got-wrong.html">What We Got Right, What We Got Wrong&lt;/a> 中提到了这一点。&lt;/p>
&lt;p>Go 包管理的转折来源于 2018 年 2 月 Go 作者之一 Russ Cox 在其博客上连发数篇文章进行了 Go Modules 的设计：&lt;/p>
&lt;p>&lt;img src="./image-20231227012240619.png" alt="image-20231227012240619">&lt;/p>
&lt;p>并最终在 Go 1.11 (2018/8) 中发布。&lt;/p>
&lt;p>按照 &lt;a href="https://go.dev/wiki/GOPATH">GOPATH wiki&lt;/a> 所述，从 Go 1.16 (2021/2) 开始，&lt;code>GO111MODULE=on&lt;/code> 变量被默认设置，除非显式修改该变量，否则 Go Modules 会默认启用。当使用 Go Modules 时，&lt;code>GOPATH&lt;/code> 将不再用于解析导入路径。但它仍然被用于存储下载的包（&lt;code>$GOPATH/pkg/mod&lt;/code>）和二进制命令（&lt;code>$GOPATH/bin&lt;/code>）。比如 Go 的 language server &lt;code>gopls&lt;/code> 通常会被安装到 &lt;code>$GOPATH/bin&lt;/code> 下，所以这个目录通常会加入到 &lt;code>$PATH&lt;/code> 中。&lt;/p>
&lt;p>以下内容皆以 Go Modules 启用为前提。&lt;/p>
&lt;h2 id="组织代码">组织代码&lt;/h2>
&lt;p>Go 程序被组织成包（packages）。一个包是一组在&lt;strong>同一文件夹&lt;/strong>下的源代码文件的集合。在同一文件中定义的函数、类型、变量、常量在同一个包的所有其他文件中可见。&lt;/p>
&lt;p>一个文件夹下无法拥有多个包。编译器会报错 &lt;code>found packages a (a.go) and b (b.go) in xxx&lt;/code>。&lt;/p>
&lt;p>一个仓库（repository，这里指 VCS，如 git 的仓库）包含一个或多个模块（modules）。一个&lt;strong>模块&lt;/strong>是一组相关的、一起发布的&lt;strong>包&lt;/strong>的集合。一个 Go 仓库通常只有一个模块，位于仓库的根目录。一个名为 &lt;code>go.mod&lt;/code> 的文件声明了&lt;em>模块路径&lt;/em>：模块中所有包的导入路径（import path）前缀。包含 &lt;code>go.mod&lt;/code> 文件的目录是模块的根目录，这个模块包含了根目录及其所有子目录下的包，直到另一个包含 &lt;code>go.mod&lt;/code> 文件的目录为止（如果有的话）。举个例子，下面的目录中根目录是一个模块，而 &lt;code>pkg/api&lt;/code> 目录是另一个。&lt;/p>
&lt;pre tabindex="0">&lt;code>├── go.mod
├── pkg
│   ├── api
│   |  └── go.mod
| └── other_pkg
&lt;/code>&lt;/pre>&lt;p>每个模块的路径不仅用于其包的导入路径前缀，也指示了 &lt;code>go&lt;/code> 命令应该到哪里去下载它。举例来说，为了下载 &lt;code>golang.org/x/tools&lt;/code> 模块，&lt;code>go&lt;/code> 命令会去 &lt;code>https://golang.org/x/tools&lt;/code> 寻找仓库。&lt;/p>
&lt;p>如果只是在本地测试，模块路径可以随便起，比如 &lt;code>example.com/what&lt;/code> 这种。当然如果你未来想要发布它，那就得遵循 Go 的规则，比如 &lt;code>github.com/your-username/your-repo-name&lt;/code>。&lt;/p>
&lt;p>&lt;em>导入路径&lt;/em>是一个用于导入一个包的字符串。一个包的导入路径是模块路径加上它在模块中的子目录。标准库中的包没有模块路径前缀。例如，模块 &lt;code>github.com/google/go-cmp&lt;/code> 在路径 &lt;code>cmp/&lt;/code> 下包含了一个包，这个包的导入路径为 &lt;code>github.com/google/go-cmp/cmp&lt;/code>。这个规则也适用于项目本身的包，如果 &lt;code>go-cmp&lt;/code> 项目在 &lt;code>foo/&lt;/code> 路径下的代码同样也导入了上述包，导入路径同样为 &lt;code>github.com/google/go-cmp/cmp&lt;/code>。&lt;/p>
&lt;p>通俗理解一下，导入路径就是文件夹路径。当一个包导入之后，我们就可以用包名来引用它了。一般而言，包名就是文件夹名，但这只是惯例，而非规定，如果确有需要可以不一致。所以下面的写法是合法的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;example.com/xxx/pkga&amp;#34;&lt;/span> &lt;span style="color:#75715e">// actually it&amp;#39;s package name is pkgb
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pkgb&lt;/span>.&lt;span style="color:#a6e22e">Func&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Go 项目的 layout 可以参考&lt;a href="https://github.com/golang-standards/project-layout">这里&lt;/a>，简而言之：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>/cmd&lt;/code> 程序的入口放在这里，每个二进制文件一个包，包名为 &lt;code>main&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所有在 &lt;code>internal/&lt;/code> 文件夹下的包只能被它的子包或者兄弟包引用。比如 &lt;code>.../a/b/c/internal/d/e/f&lt;/code> 这个包能够被 &lt;code>.../a/b/c&lt;/code> 路径下的包导入，而无法被 &lt;code>.../a/b/g&lt;/code> 路径下的包导入&lt;/p>
&lt;p>在项目根目录下的 &lt;code>/internel&lt;/code> 文件夹就意味着它们只能被项目本身引用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>/pkg&lt;/code> 库的代码，并且允许其他项目使用的，放在这里&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>一个典型的项目结构如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>├── cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── bc_node
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│      └── main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── docs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── designs.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── go.mod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── go.sum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── pkg
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│      └── block.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── internal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   ├── block.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   ├── db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   │   └── db.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│   └── network
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│      ├── rpc_client
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│      │   └── rpc_client.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│      ├── rpc_server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│      │   └── rpc_server.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│      ├── rpc_test.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│      └── state.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── Makefile
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── README.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="包管理">包管理&lt;/h2>
&lt;p>Go 模块的版本采用&lt;a href="https://semver.org/">语义化版本&lt;/a>（semantic versioning, semver），想必大家都很熟悉了。&lt;/p>
&lt;p>大版本的更新会导致导入路径的变化，v0/v1 版本的模块名没有版本后缀，如 &lt;code>github.com/xx/xxxx&lt;/code>。从 v2 开始需要版本后缀，如 &lt;code>github.com/xx/xxxx/v2&lt;/code>，这个后缀需要在 &lt;code>go.mod&lt;/code> 中声明。如果一个模块发布了 v2，但是没有在 &lt;code>go.mod&lt;/code> 中加入 &lt;code>/v2&lt;/code> 的后缀，其他包将无法 import v2 版本：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ go get -u github.com/cjc7373/go-module-test/c@v2.0.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>go: github.com/cjc7373/go-module-test/c@v2.0.0: invalid version: module contains a go.mod file, so module path must match major version &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;github.com/cjc7373/go-module-test/c/v2&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果一个模块没有使用 Go Modules（即没有 &lt;code>go.mod&lt;/code> 文件），并且发布了一个 v2 及以上的版本，那么它作为一个依赖被引入时，我们会看到 &lt;code>github.com/xx/xxxx v4.1.0+incompatible&lt;/code> 这样的版本号。&lt;/p>
&lt;p>模块的发布依赖于 VCS 的 tagging 功能。发布一个包就是打一个 tag。如果一个仓库有多个模块，则需要在 tagging 中加上模块路径的前缀，如果仓库位于 &lt;code>example.com/mymodules/&lt;/code>，模块路径为 &lt;code>example.com/mymodules/module1&lt;/code>，则打的 tag 应该为 &lt;code>module1/v1.2.3&lt;/code> 这种形式。（这里猜测模块路径是和文件夹路径对应的，但我没有实验过）&lt;/p>
&lt;h2 id="gomod">&lt;code>go.mod&lt;/code>&lt;/h2>
&lt;p>&lt;code>go.mod&lt;/code> 文件中，除了最常用的 &lt;code>require&lt;/code> 指令之外，还能够包括其他一些指令，例如：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>exclude&lt;/code>，用于阻止一个模块版本被载入。这一指令仅对当前的 main 模块生效（也就是说，如果一个依赖的 &lt;code>go.mod&lt;/code> 文件中包含了 &lt;code>exclude&lt;/code> 指令，该指令将不会生效）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>replace&lt;/code>，用于替换一个模块指定版本（或是所有版本）的内容，替换的路径可以是模块的另一个版本，另一个模块，或是一个相对路径。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go.mod" data-lang="go.mod">&lt;span style="display:flex;">&lt;span>replace (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> golang.org&lt;span style="color:#f92672">/&lt;/span>x&lt;span style="color:#f92672">/&lt;/span>net v1.&lt;span style="color:#ae81ff">2.3&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> example.com&lt;span style="color:#f92672">/&lt;/span>fork&lt;span style="color:#f92672">/&lt;/span>net v1.&lt;span style="color:#ae81ff">4.5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> golang.org&lt;span style="color:#f92672">/&lt;/span>x&lt;span style="color:#f92672">/&lt;/span>net &lt;span style="color:#f92672">=&amp;gt;&lt;/span> example.com&lt;span style="color:#f92672">/&lt;/span>fork&lt;span style="color:#f92672">/&lt;/span>net v1.&lt;span style="color:#ae81ff">4.5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> golang.org&lt;span style="color:#f92672">/&lt;/span>x&lt;span style="color:#f92672">/&lt;/span>net &lt;span style="color:#f92672">=&amp;gt;&lt;/span> .&lt;span style="color:#f92672">/&lt;/span>fork&lt;span style="color:#f92672">/&lt;/span>net
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这一指令同样仅对当前的 main 模块生效。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>详细的文档可见&lt;a href="https://go.dev/ref/mod#go-mod-file">这里&lt;/a>。&lt;/p>
&lt;h2 id="设计原则">设计原则&lt;/h2>
&lt;p>所有的包管理都是为了解决依赖地狱问题（&lt;a href="https://en.wikipedia.org/wiki/Dependency_hell">Dependency hell&lt;/a>），即一些包拥有同样的共享的包，但它们依赖与这些包的不同的、互不兼容的版本。&lt;/p>
&lt;p>Russ Cox 在&lt;a href="https://research.swtch.com/vgo-principles">他的博客&lt;/a>中回顾了 Go Modules 的设计原则。总结一下就是：&lt;/p>
&lt;ul>
&lt;li>导入兼容性原则：如果旧包和新包的导入路径相同，则新包必须兼容旧包。&lt;/li>
&lt;li>最小版本选择（Minimal Version Selection, MVS）原则：使用满足需求的最旧版本，而不是最新版本。&lt;/li>
&lt;/ul>
&lt;p>为什么要这么设计呢？&lt;/p>
&lt;h3 id="兼容性">兼容性&lt;/h3>
&lt;p>Go 非常重视向后兼容。&lt;/p>
&lt;blockquote>
&lt;p>遵循 Go 1 规范编写的软件应该能够在规范的生命周期之内继续正确地编译和运行，并无需更改。在现在能够工作 Go 程序应该能够在未来的 Go 1 版本中继续工作。&lt;/p>
&lt;p>— &lt;a href="https://golang.org/doc/go1compat">&lt;em>golang.org/doc/go1compat&lt;/em>&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Go 的&lt;a href="https://go.dev/blog/publishing-go-modules">一篇博客&lt;/a>中有一个例子，标准库中的 &lt;code>strings&lt;/code> 包有两个函数：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Split&lt;/code> 把一个字符串分割成由参数中的分隔符分割的一些子串&lt;/li>
&lt;li>&lt;code>SplitN&lt;/code> 能够控制分割的子串的数量&lt;/li>
&lt;/ul>
&lt;p>但是又存在 &lt;code>Replace&lt;/code> 函数来替换字符串中的某个子串 n 次，&lt;code>ReplaceAll&lt;/code> 函数来替换所有出现的子串。我们肯定觉得，为什么不使用 &lt;code>Split&lt;/code> 的命名规则，把它们命名成 &lt;code>Replace&lt;/code> 和 &lt;code>ReplaceN&lt;/code> 呢？但是为了向后兼容，Go 没有这么做。&lt;/p>
&lt;p>所以 Go Modules 选择了 semver。semver 保证了只有 major version 的变化才会有 breaking changes，在此情况下，模块的导入路径会发生变化（即带上大版本后缀）。否则，新版本的模块必须向后兼容旧版本。&lt;/p>
&lt;p>这么做的另一个好处是大型项目可以逐渐更新一个依赖，因为上述做法允许了一个模块的两个大版本同时存在。&lt;/p>
&lt;h3 id="可重复性">可重复性&lt;/h3>
&lt;p>最小版本选择原则是为了可重复性。从依赖的约束中得到依赖的具体版本被称为依赖解析（Dependency Resolution）。对于其他的包管理器（如 pip, cargo, npm）来说，一般都会选择满足约束的最新版本，并且有一个 lock 文件来保证构建的可重复性。即第一次构建（依赖解析时）会生成 lock 文件，之后的构建都会从 lock 文件里取得和第一次一样的依赖版本。然而，lock 文件只对当前项目生效。现在假设如下情况：&lt;/p>
&lt;p>&lt;img src="./image-20240104191444433.png" alt="image-20240104191444433">&lt;/p>
&lt;p>C 1.8 指定了 D &amp;gt;= 1.4 的约束，并且在 lock file 中选择了 D 1.5 作为依赖。现在 A 指定了 C 1.8 作为依赖，A 在构建时会重新进行依赖解析，假设这时 D 1.5 是最新的，那么 A 就会选择 D 1.5 作为依赖。过了几个月之后，D 发布了 1.6，它 break 了 C 1.8，这时候 C 因为有 lock file 仍然能正常构建。但是如果另一个项目 B 新依赖了 C 1.8，那么依赖解析时就会选择到 D 1.6，这就 break 了 B。依赖解析到的版本和时间有关，破坏了可重复性。&lt;/p>
&lt;p>版本选择问题是一个 NP 完全问题，本质上在解决一个可满足性问题。对于给定约束，可能存在多个结果，依赖解析中选择哪一种结果是不确定的。考虑如下情况：&lt;/p>
&lt;p>&lt;img src="./image-20240104192822040.png" alt="image-20240104192822040">&lt;/p>
&lt;p>图中以 Dep 和 Go Modules 为例说明了依赖解析的过程，这里虽然两者选择的 D 版本不同，但都能够成功构建。现在假设 D 发布了有 bug 的 1.6 版本，break 了 C 1.8。C 的开发者为了绕过 bug 添加了 D &amp;lt; 1.6 的约束，并发布了 1.9 版本。这时让 Dep 重新进行依赖解析：&lt;/p>
&lt;p>&lt;img src="./image-20240104193149370.png" alt="image-20240104193149370">&lt;/p>
&lt;p>会产生不止一种满足约束的结果。此时 Dep 首先会尝试使用最新的 B 1.4 和 C 1.9，但是这并不能满足约束。如果 Dep 接着尝试使用下一个 B 版本 1.3（右图），那么会解析到 D 1.5，构建成功；如果 Dep 尝试用下一个 C 版本 1.8（左图），那么会解析到 D 1.6，构建失败。Dep 选择哪种结果完全取决于它的内部实现，并不确定。而 Go Modules 则具备可重复性。&lt;/p>
&lt;p>MVS 的设计使得 go 的依赖解析是确定性的，所以 go 并不需要一个 lock 文件。&lt;code>go.sum&lt;/code> 仅仅起了存储校验信息的作用，并不起 lock 文件的作用。&lt;/p>
&lt;h2 id="-indirect">// indirect&lt;/h2>
&lt;p>等一下，按照上面对于 MVS 的理解，我们只需要记录当前模块的所有直接依赖，但是为什么在 &lt;code>go.mod&lt;/code> 文件中还能看见大量的 &lt;code>require example.com/foo // indirect&lt;/code> 的语句呢？这里 indirect 指的就是模块的间接依赖。答案是在 1.16 之前，除非需要一个和 MVS 解析到的版本不同的版本，才需要给间接依赖加上 &lt;code>require&lt;/code> 指令。但是在 1.17 及之后，需要它来提供一些额外信息。&lt;/p>
&lt;p>这便是&lt;a href="https://go.googlesource.com/proposal/+/master/design/36460-lazy-module-loading.md">懒模块加载&lt;/a>，&lt;/p>
&lt;h2 id="尾巴">尾巴&lt;/h2>
&lt;p>在下一篇博客中，我们会讨论模块镜像（Proxy）、校验数据库和工作区。&lt;/p>
&lt;h2 id="see-also">See also&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://go.dev/doc/code">How to Write Go Code&lt;/a> 是 Go 代码组织的简明指南&lt;/li>
&lt;li>&lt;a href="https://go.dev/doc/modules/managing-source">Managing module source&lt;/a> 中说明了一个仓库中管理多个模块的方式&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/57355929/what-does-incompatible-in-go-mod-mean-will-it-cause-harm">What does &amp;lsquo;incompatible&amp;rsquo; in go.mod mean, will it cause harm?&lt;/a> 虽然问的是 incompatible 的含义，但是最高赞答案实际解释了 Go Modules 的大部分概念&lt;/li>
&lt;/ul>
- https://blog.coherence.codes/posts/2024/go_pkg_mgmt_1_toturial/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>记一次 mpv 异常关闭的调试</title><link>https://blog.coherence.codes/posts/2023/mpv_debug/</link><pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/mpv_debug/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/mpv_debug/ -&lt;h2 id="查不出的问题">查不出的问题&lt;/h2>
&lt;p>长久以来我都被 mpv 的一个问题所困扰，那就是在正常播放视频时 mpv 有概率会自动退出（通常是按下暂停键的时候）。通过 &lt;code>-v -v -v&lt;/code> 参数查看详细日志发现 mpv 接收到了 stop 命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>cplayer&lt;span style="color:#f92672">]&lt;/span> Run command: stop, flags&lt;span style="color:#f92672">=&lt;/span>64, args&lt;span style="color:#f92672">=[&lt;/span>flags&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是这个命令是谁发的不得而知。一开始怀疑是插件的问题，然而禁用所有插件（&lt;code>~/.config/mpv/scripts&lt;/code> 目录）后问题依旧。后尝试用 &lt;code>--no-config&lt;/code> 参数禁用所有配置，发现问题消失，于是尝试注释掉所有 &lt;code>mpv.conf&lt;/code> 中的配置，发现问题依旧。我还怀疑过是 &lt;code>pipewire&lt;/code>/&lt;code>xorg&lt;/code> 的问题，但是并没有搜索到相关信息。&lt;/p>
&lt;p>我还观察到 vlc 是不是也会出现播放时自动停止的现象，另外 youtube/bilibili 播放视频时会经常自动跳转到开头。后来证实这其实都是同一个问题导致的..&lt;/p>
&lt;h2 id="线索">线索&lt;/h2>
&lt;p>在 mpv 的 issue 中找到了一个问题相同的 &lt;a href="https://github.com/mpv-player/mpv/issues/11988">bug report&lt;/a>，开发者认为这是插件导致的，但是我已经禁用所有插件了，于是我留言询问应该如何排查，有一个人指出了可能和 &lt;code>mpv-mpris&lt;/code> 有关。&lt;/p>
&lt;p>&lt;a href="https://wiki.archlinux.org/title/MPRIS">MPRIS&lt;/a> 是一个 dbus 接口，提供了控制媒体播放器的相应 API，绝大多数应用，包括上述提到的几个，都支持这一接口。mpv 的 mpris 支持通过 &lt;code>mpv-mpris&lt;/code> 包提供。看到这个名字我恍然大悟，&lt;code>mpv-mpris&lt;/code> 由系统包管理器安装，因此并没有出现在用户的插件目录下。当即我查看了 &lt;code>mpv-mpris&lt;/code> 的源码，发现其为 mpv C 拓展，而不是常见的 Lua 拓展。&lt;/p>
&lt;p>从&lt;a href="https://github.com/hoyon/mpv-mpris/blob/16fee38988bb0f4a0865b6e8c3b332df2d6d8f14/mpris.c#L602C26-L602C26">这里&lt;/a>可以看到，它在收到 mpris 的 &lt;code>Stop()&lt;/code> 方法后，会向 mpv 发送 stop 命令，因此我准备加一行日志看看到底是不是 &lt;code>mpv-mpris&lt;/code> 导致了上述问题。询问了 ChatGPT 之后发现其对于如何在 mpv C 扩展中打印日志完全是在瞎扯.. 后来发现直接用 &lt;code>printf&lt;/code> 就行.. 从函数签名可以看到其包含了 sender 的信息，于是将其打印。这里我并没有 clone 仓库进行构建，而是直接复制 archlinux 中的 PKGBUILD，先用 &lt;code>makepkg -o&lt;/code> 下载解压源码，修改后再用 &lt;code>makepkg -e&lt;/code> 进行构建，这样做的好处是无需关心具体的构建流程以及如何应用构建后的插件，build 完直接装就行。&lt;/p>
&lt;p>在复现问题之后发现果然是 &lt;code>mpv-mpris&lt;/code> 调用了 stop 命令，日志为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>mpris: sender: :1.41, _object_path: /org/mpris/MediaPlayer2, interface_name: org.mpris.MediaPlayer2.Player, method_name: Stop, parameters: &lt;span style="color:#f92672">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>继续询问 ChatGPT 如何从 &lt;code>:1.41&lt;/code> 这个标识符得到发送者的进程，这次它倒没有瞎扯，告诉我 dbus 包含一个内省方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ dbus-send --session --dest&lt;span style="color:#f92672">=&lt;/span>org.freedesktop.DBus --type&lt;span style="color:#f92672">=&lt;/span>method_call --print-reply /org/freedesktop/DBus org.freedesktop.DBus.GetConnectionUnixProcessID string:&lt;span style="color:#e6db74">&amp;#34;:1.41&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>method &lt;span style="color:#66d9ef">return&lt;/span> time&lt;span style="color:#f92672">=&lt;/span>1702192468.323155 sender&lt;span style="color:#f92672">=&lt;/span>org.freedesktop.DBus -&amp;gt; destination&lt;span style="color:#f92672">=&lt;/span>:1.2850 serial&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span> reply_serial&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uint32 &lt;span style="color:#ae81ff">1688&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再用 ps 等命令查看，发现该进程为 kdeconnect。直接上 bugs.kde.org 搜索得到一个类似的 &lt;a href="https://bugs.kde.org/show_bug.cgi?id=476123">bug report&lt;/a>，不过除了作者没有人回应。&lt;/p>
&lt;p>翻找源码发现大概是在 &lt;a href="https://invent.kde.org/network/kdeconnect-kde/-/blob/master/plugins/mpriscontrol/mpriscontrolplugin.cpp#L284">mpriscontrolplugin.cpp#L284&lt;/a> 调用的 mpris Stop 方法，去掉注释重新编译后查看日志发现如下条目：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>kdeconnect.core: TCP connection done (i&amp;#39;m the existing device)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.core: Starting server ssl (I&amp;#39;m the client TCP socket)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.core: Socket successfully established an SSL connection
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.core: It is a known device &amp;#34;xxxx&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.plugin.mpris: Calling action &amp;#34;Stop&amp;#34; in &amp;#34;org.mpris.MediaPlayer2.mpv&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.plugin.notification: Not found noti by internal Id: &amp;#34;0|org.kde.kdeconnect_tp|-1850276765|null|10264&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.plugin.mpris: MPRIS service &amp;#34;org.mpris.MediaPlayer2.mpv&amp;#34; just went offline
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kdeconnect.plugin.mpris: Mpris removePlayer &amp;#34;org.mpris.MediaPlayer2.mpv&amp;#34; -&amp;gt; &amp;#34;mpv&amp;#34;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基本能够确认是从这里进行调用的了。根据函数推断该函数是处理配对的其他设备发送的请求，出问题时我配对的设备只有我的安卓手机，所以问题应该出在安卓端。看了眼 kdeconnect-android 的源码，看不懂啊&amp;hellip; 本次 debug 到此结束。&lt;/p>
&lt;p>由于 vlc/chromium 同样实现 mpris 接口，所以上面观察到的现象基本可以确认也是 kdeconnect 导致的了。&lt;/p>
&lt;h2 id="怎么办呢">怎么办呢？&lt;/h2>
&lt;p>目前的 workaround 是关闭 KDE Connect 中的 Multimedia control receiver 插件，drawback 是其他设备无法再控制本机的媒体播放器了，不过我也不怎么用，问题不大。&lt;/p>
- https://blog.coherence.codes/posts/2023/mpv_debug/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>MIT 6.824 学习笔记(二) Raft</title><link>https://blog.coherence.codes/posts/2023/mit_6.824_2_raft/</link><pubDate>Sun, 01 Oct 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/mit_6.824_2_raft/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/mit_6.824_2_raft/ -&lt;p>本文主要是对 Raft 论文的翻译，为了保持准确性，我会尽量使用英文术语。&lt;/p>
&lt;h2 id="introduction">Introduction&lt;/h2>
&lt;p>在过去十年，Leslie Lamport 的 Paxos 协议几乎成为了共识的同义词。Paxos 首先定义了一种协议来对单个决定达成共识, 比如一条单个的 log entry, 这被称为 single-decree Paxos。 其支持多个决定的版本 (比如 log) 被称为 muti-Paxos。然而，Paxos 的缺点是难以理解，并且没有提供一个良好的基础来构建可行的实现。&lt;/p>
&lt;blockquote>
&lt;p>试图为这个主题增添一点幽默的尝试以惨淡的失败告终。……这个希腊寓言显然使阅读论文的人们分心了，以致于他们无法理解这个算法。我把论文发给了一些人，其中包括 Nancy Lynch, Vassos Hadzilacos 和 Phil Bernstein，他们声称读过了论文。几个月后我发邮件给他们问了如下问题：&lt;/p>
&lt;pre>&lt;code>你能否实现一个分布式数据库，它能容忍任何进程的故障（可能是所有进程）而不牺牲一致性，并且在超过半数进程恢复之后继续正常工作？
&lt;/code>&lt;/pre>
&lt;p>没有人察觉到这个问题和 Paxos 算法之间有任何联系。&lt;/p>
&lt;p>—— Leslie Lamport &lt;a href="https://lamport.azurewebsites.net/pubs/pubs.html?from=https://research.microsoft.com/users/lamport/pubs/pubs.html&amp;amp;type=path#lamport-paxos">对 The Part-Time Parliament 的评论&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>相较于 Paxos，Raft 的目标是易于理解且符合直觉。为了使 Raft 易于理解，作者采取了解耦 (Raft 将共识问题分解成几个子问题 leader election, log replication, safety, and membership changes) 和缩减状态空间的方式。&lt;/p>
&lt;p>Raft 和已有的共识算法类似（尤其是 Viewstamped Replication），但它有一些新特性。Raft 采取了强 leader 的设计，例如 log entry 只会从 leader 向其他节点分发。这可能是为了性能考虑（比无 leader 要更快，RPC 也更少）Raft 采用基于随机计时器的 leader 选举, 从而用一种简单的方法来解决冲突。另外还有处理成员变更方面的改进。&lt;/p>
&lt;p>为了解决单点故障问题，Raft 采用了 Majority Vote，基本上任何操作都需要得到多数确认才能够执行。为了避免 tie，Raft 的节点数量必须为奇数。因此在一个 2f+1 个节点的系统中，最多允许 f 个节点故障，f+1 即为法定人数（quorum）。&lt;/p>
&lt;p>如果 server 不出错，网络也很稳定，共识算法是很简单的，比如在 Raft 中，leader 被选举出来，client 的请求由 leader 处理并转发给 followers，所有 server 都和 leader 保持一致，这个过程是很简单并且直观的。这些算法真正处理的、细节繁杂的地方是 server 出错、RPC 受网络影响（包括包的延迟，重复，顺序改变，丢失，网络分区）的时候。&lt;/p>
&lt;h2 id="replicated-state-machines-复制状态机">Replicated state machines (复制状态机)&lt;/h2>
&lt;p>通常实现主从复制有两种方法：&lt;/p>
&lt;ul>
&lt;li>状态转移（State trasnsfer），主服务器将存储的所有状态都发送给从服务器&lt;/li>
&lt;li>复制状态机（Replicated State Machine），将服务器视为确定性的状态机，主服务器将所有输入发送给从服务器，那么他们在任意时刻的状态都是相同的&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="./image-20230907175938021.png" alt="image-20230907175938021">&lt;/p>
&lt;p>Replicated state machines 通常使用 replicated log 实现. 每个节点存储一份 log (一系列指令), 其状态机按顺序执行它们. 每个状态机获得的 log 都是完全一致的, 所以它们是确定性的, 存储有完全相同的状态. Replicated log 的一致性由共识算法保证, 一个节点上的共识模块从 client 接收指令, 并把它们加到 log 中, 它和其他节点的共识模块通信以保证 log 存储了相同顺序的指令。在 Raft 中，状态机由上层应用负责处理。&lt;/p>
&lt;p>共识算法需要具有以下属性:&lt;/p>
&lt;ul>
&lt;li>在非拜占庭错误 (包括 network delays, partitions, and packet loss, duplication, and reordering) 下保证安全性 (safety), 即不会返回不正确的结果&lt;/li>
&lt;li>只要多数 (即超过一半) 节点工作, 服务就是可用的&lt;/li>
&lt;li>不依赖时间来确保一致性, 错误的时间或是极端情况下的延迟只会导致可用性问题&lt;/li>
&lt;li>只要多数节点回应, 一条命令就能够完成, 少数 slow servers 不会影响整个系统的性能&lt;/li>
&lt;/ul>
&lt;h2 id="raft-共识算法">Raft 共识算法&lt;/h2>
&lt;p>&lt;img src="./image-20230908182459520.png" alt="image-20230908182459520">&lt;/p>
&lt;p>这张图（论文中的 Figure 2）总结了 Raft 协议（除了成员变更和 log 压缩），我们在实现 Raft 协议时会反复看这张图。&lt;/p>
&lt;p>Raft 主要由两个 RPC 构成：&lt;/p>
&lt;ul>
&lt;li>&lt;code>RequestVote RPC&lt;/code>，由 candidate 请求，用于收集投票&lt;/li>
&lt;li>&lt;code>AppendEntries RPC&lt;/code>，由 leader 请求，用于心跳和复制 log entries&lt;/li>
&lt;/ul>
&lt;p>Raft 首先将选举一个 leader, leader 的存在能够简化对 replicated log 的管理，比如 leader 能够独自决定把新的 entry 放在哪里，数据自然地由 leader 流向其他 servers。leader 拥有完全管理 replicated log 的权力，leader 从 clients 接受 log entries, 分发给其他节点, 并告诉它们何时能应用这些 log entries 到它们自己的状态机。&lt;/p>
&lt;p>关键性质:&lt;/p>
&lt;ul>
&lt;li>Election Safety: 一个任期中只有一个 leader&lt;/li>
&lt;li>Leader Append-Only: leader 不会覆盖或删除自己的 log entry, 只会 append&lt;/li>
&lt;li>Log Matching: 如果两份 log 中某一个 entry 的 index 和 term 相同, 那么两份 log 从头开始直到该 entry 都是相同的&lt;/li>
&lt;li>Leader Completeness: 如果一个 log entry 在某一 term 中 commit 了, 这个 entry 会存在于任何更高任期的 leader 的 log 中&lt;/li>
&lt;li>State Machine Safety: 如果一个 server 将一个指定 index 的 log entry 应用到了 state machine 中（i.e. commit 了这个 entry）, 没有其他 server 会在那个 index 上会应用其他的 entry&lt;/li>
&lt;/ul>
&lt;p>这些性质看起来比较抽象，然而是保证 Raft 的安全性所必须的，下文会详细解释。&lt;/p>
&lt;h3 id="leader-选举">leader 选举&lt;/h3>
&lt;p>任何一个节点处于以下三种状态: leader, follower, candidate&lt;/p>
&lt;p>&lt;img src="./image-20230907175951530.png" alt="image-20230907175951530">&lt;/p>
&lt;p>上图描述了 server 所有的状态变化，下面描述几个关键的步骤：&lt;/p>
&lt;ul>
&lt;li>Follower -&amp;gt; Candidate：开始选举，follower 递增 term 并进入 candidate 状态，它接着给自己投票并向其他 server 发送 RequestVote RPC。每个 server 在一个 term 只能给一个 candidate 投票，基于先来先得的原则&lt;/li>
&lt;li>Candidate -&amp;gt; Leader：当 candidate 接收到了多数票（majority）之后将赢得选举，接着它会马上发送心跳包宣告自己的权威并阻止新的选举。leader 会一直保持 leader 状态，除非 a). 它 fail 了 b). 由于丢包等原因导致某个 follower 的选举计时器超时了&lt;/li>
&lt;li>Candidate -&amp;gt; Follower：如果 candidate 收到其他 server 的 AppendEntries RPC 宣称是 leader，并且其 term 不小于 candidate 的当前 term，则该 leader 合法，candidate 回退到 follower 状态&lt;/li>
&lt;li>Candidate -&amp;gt; Candidate：如果没有产生多数票，在超时后选举将重复进行，为了打破僵局 Raft 使用随机的选举超时时间&lt;/li>
&lt;li>无论何时，candidate 和 leader 只要收到一个 term 比自己大的 RPC，它必须转变为 follower&lt;/li>
&lt;/ul>
&lt;p>由于在任何一个 term 中，一个 server 只能够投一次票，而只有得到多数票才能成为 leader，所以 Election Safety（一个任期中只有一个 leader）得以满足。&lt;/p>
&lt;h3 id="log-复制-replication">log 复制 (replication)&lt;/h3>
&lt;p>log 由 entry 组成，每个 entry 都有一个唯一递增的 log index（可以理解为在数组中的 index）。entry 中包含 term 和给状态机的指令。&lt;/p>
&lt;p>当一个 log entry 能够被应用到状态机上时 (i.e. 当 leader 知道这个 entry 已经被 replicate 到多数 server 上时，但下文会说明一种例外情况), 我们称这个 entry 为 committed. leader 决定哪些 entry 能够 commit，并在下一次 AppendEntries RPC 中将这个状态告知 followers. Raft 保证了 commited entries 是持久的并&lt;strong>最终&lt;/strong>会应用到所有 servers 上。&lt;/p>
&lt;p>leader 维护 &lt;code>commitIndex&lt;/code>，即最高的 committed entry index，并且会将这个 index 包含在 AppendEntries RPC 中。&lt;/p>
&lt;p>Raft 协议中的 Log Matching 性质实际上由两部分组成：&lt;/p>
&lt;ul>
&lt;li>如果两份 log 中某一个 entry 的 index 和 term 相同, 那么这两个 entry 相同
&lt;ul>
&lt;li>这是因为一个 term 只有一个 leader，而一个 leader 对于给定 log index 只能创建最多一个 entry，并且 log entry 从不改变它们在 log 中的位置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果两份 log 中某一个 entry 的 index 和 term 相同, 它们之前的 entries 都是相同的
&lt;ul>
&lt;li>这个性质由 AppendEntries 的一个一致性检查保证。leader 会把新 entries 的前一个 entry 的 index 和 term 包含在 AppendEntries RPC 中（&lt;code>prevLogIndex&lt;/code> 和 &lt;code>prevLogTerm&lt;/code>），这样如果 follower 找不到这样一个 entry，它就会拒绝新的 entries&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="./image-20230907180012141.png" alt="image-20230907180012141">&lt;/p>
&lt;p>正常情况下所有 server 的 log 会保持一致，然而当 leader crash 时便会产生不一致。follower 可能会缺一些 entries，也可能多一些，也可能两者都有。leader 通过强制 follower 的 log 和自己同步来解决不一致。leader 为每个 follower 维护一个 &lt;code>nextIndex&lt;/code>，即下一个将会被发给 follower 的 log entry。在一开始 leader 会初始化 &lt;code>nextIndex&lt;/code> 为它最新一个 log entry 的下一个位置，当某个 follower 拒绝了一次 AppendEntries 之后，leader 递减 &lt;code>nextIndex&lt;/code> 并重试 AppendEntries RPC。最终 &lt;code>nextIndex&lt;/code> 会到达一个 leader 和 follower 都一致的位置，follower 在那个位置之后的所有 entries 都会被 leader 的覆盖。上述描述同时也符合了 Leader Append-Only（leader 只会追加自己的 log） 这个性质。&lt;/p>
&lt;h3 id="安全性">安全性&lt;/h3>
&lt;p>如果 Figure 7 中的 (f) 被选举为了下一个 leader，那么 term 4 及之后的更改岂不是都丢失了？因此 Raft 限制了谁能够被选为 leader，以便满足 Leader Completeness 性质（committed entry 会存在于任何更高任期的 leader 的 log 中）。首先给出 log 新旧的定义：如果 candidate 的 log 至少和多数 log 一样新（at least as up-to-date as any other log in the majority）那么它包含了所有 committed entries；如果 log 的最后一个 entry term 更大，那么它就更新。如果 term 相同，那么更长的 log 更新。在 RequestVote RPC 中，candidate 会包含 &lt;code>lastLogIndex&lt;/code> 和 &lt;code>lastLogTerm&lt;/code>，只有当 candidate 的 log 更新时一个 server 才会投票给它。&lt;/p>
&lt;p>&lt;img src="./image-20230909175357672.png" alt="image-20230909175357672">&lt;/p>
&lt;p>当 leader commit 一个来自它之前 term 的 entry 时，可能会遭遇上图的问题，在 (c) 中，来自 term 2 的 entry 已经被复制到多数 server 上了，然而如果 (d) 发生了，它仍然会被来自 term 3 的 entry 覆盖。因此 Raft 将 commit 定义为只有来时当前 term 的 entry 才能够通过 replica 计数来 commit，而来自之前任期的 entry 只能够通过在它之后的 entry 被 commit 来间接 commit（Log Matching 性质）。&lt;/p>
&lt;p>我们可以用反证法来证明这么做的安全性（非严格证明），假设节点数量为 2f+1，log index m 已经被 commit 了，并且位于 f+1 个 server 上。此时一个不包含 m 的 server x 想要竞选 leader。为了得到多数票，至少有一个包含 m 的 server y需要投票给 x，此时需要 x 比 y 更新。根据 up-to-date 的定义，可能有以下两种情况：&lt;/p>
&lt;ul>
&lt;li>x 和 y 的最后一个 log entry term 相同，且 x 的 log 至少和 y 一样长。此时根据 Log Matching 性质，x 必然包含 m，故产生矛盾。&lt;/li>
&lt;li>x 的最后一个 log entry（设为 p）term 更大。那么 p 的 term 必然大于 m 的 term。既然 m 已经 commit 了，创建了 p 的那一任 leader 必然在 log 中包含了 m，所以 x 也必然包含 m，产生矛盾。&lt;/li>
&lt;/ul>
&lt;h3 id="时机和可用性">时机和可用性&lt;/h3>
&lt;p>在 leader 选举中，时机（Timing）是很关键的，如果 RPC 用时过长，那么 candidate 在超时之前将无法赢得选举。Raft 需要满足以下时机约束：$broadcastTime ≪ electionTimeout ≪ MTBF$，broadcastTime 是平均一次 RPC 的时间，electionTimeout 是选举超时时间，MTBF（Mean Time Between Failures）是发生两次 server 故障的平均间隔时间。&lt;/p>
&lt;h2 id="集群成员变更">集群成员变更&lt;/h2>
&lt;p>这里指的是增减 server。虽然我们总是能够通过下线整个集群、更新配置、上线集群的方式来增减 server，但这样就减少了可用性。为了使配置变更是安全的，必须保证同一 term 不可能有两个 leader 被选举出来。然而，任何直接由旧配置转变为新配置的做法都是不安全的，如下图所示：&lt;/p>
&lt;p>&lt;img src="./image-20230928111923370.png" alt="image-20230928111923370">&lt;/p>
&lt;p>为了保证安全性，Raft 采取了一种两阶段的策略，集群会切换到一个过渡的配置，称为 joint consensus。论文没有给出这个过程的具体实现，我对这部分也理解得不是很清楚。&lt;/p>
&lt;h2 id="log-压缩compaction">log 压缩（compaction）&lt;/h2>
&lt;p>如果没有压缩，log 的大小会无限增长，并且在 server 故障重启后重新应用 log 的时间会非常长，这显然是不划算的。&lt;/p>
&lt;p>快照（snapshot）是最简单的压缩方式。在一次快照中，当前的系统状态被写入到非易失存储中，然后到这个时刻的所有 log 将被丢弃。&lt;/p>
&lt;p>&lt;img src="./image-20230928141311077.png" alt="image-20230928141311077">&lt;/p>
&lt;p>然而，快照带来了新的复杂度。如果一个 leader 的 log 如上图所示，在一次快照之后 log 中的第一个 entry 为 6，但是如果一个 follower 的 log 还停留在最后一个 entry 为 4，那么这个 follower 永远无法获得 entry 5 了。Raft 的做法是引入了一个新的 InstallSnapshot RPC，用于把 leader 的当前 snapshot 发送给 follower。&lt;/p>
&lt;p>snapshot 的创建过程依赖于上层应用，因为 Raft 对于状态机里的状态知之甚少。但是何时创建 snapshot 由 Raft 决定，一个简单的策略是当 log 达到固定大小时创建。&lt;/p>
&lt;p>每个 server 能够独立创建 snapshots，因而其偏离了 Raft 的强 leader 原则，但是由于在创建 snapshot 时共识已经达成了，所以这不会有问题。如果只有 leader 能创建 snapshot，那么有两个缺点 a) 每次发送 snapshot 都会浪费网络带宽 b) leader 的实现会变得复杂，因为它必须同时发送 snapshot 和新的 entries。&lt;/p>
&lt;h2 id="客户端交互">客户端交互&lt;/h2>
&lt;p>client 只会和 leader 交互，在 client 刚启动时，它可能会连接到一个随机的 server，若该 server 不为 leader，则 server 会拒绝这个请求并提供 leader 的信息。&lt;/p>
&lt;p>Raft 的目标是提供可线性化（linearizable）的语义，即每个操作会在调用和回复之间的某个时间立刻执行执行一次（exactly once）。然而，Raft 可能会执行一个操作多次，如果 leader 在 commit log entry 之后回复 client 之前崩溃了，client 会重试请求，导致一个操作执行了两次。这个问题的解决方案是每个 client 为对每个操作分配一个递增的序列号，leader 维护每个 client 最新的序列号。如果 leader 收到了一个请求包含已经被执行的序列号，那么它就不会再次执行这个请求。&lt;/p>
&lt;p>我们能够不向 log 写任何东西就处理读请求（Read-only operations），然而如果没有额外的措施，读请求可能会读到过时的（stale）数据。如由于网络分区当前 leader 已经被新的 leader 取代了，但是当前 leader 并不知道这一点。为了保证不会读到过时的数据，在 leader 刚当选时它必须发送一个 no-op entry，以便找出哪些 entry 已经 commit 了。其次 leader 必须检查它是否被新的 leader 取代了，这可以通过发送心跳包来检查是否有多数 server 回应来实现。&lt;/p>
&lt;h2 id="notes">Notes&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Raft 是强一致性的协议，因为 commit 过的 log 总是一致的，如果出现网络分区则只有多数区能够达成共识，所以其符合了 CAP 原则中的 CP。另一种应对 split-brain 的方式是允许 split-brain，在网络恢复之后通过一些机制来调谐分叉的状态（reconcile the diverging state），通常这被称为最终一致性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Q：一个 Raft 集群通常位于一个物理位置还是说可以部署在地理上不同的数据中心里？&lt;/p>
&lt;p>A：典型的部署方式是一个数据中心。我们会在之后看到一些运行 Paxos 的系统（如 Spanner）能够跨数据中心，其通常是一种无 leader 的设计，以便一个 client 能够同一个本地 server 通信。&lt;/p>
&lt;p>Google 的 Chubby 论文报告了它们的 Chubby 部署通常是在一个数据中心里，除了 root Chubby 是跨数据中心的（chubby 并未使用 raft，而是用了基于 Paxos 的一个内部库）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="可线性化linearizability">可线性化（Linearizability）&lt;/h2>
&lt;p>并发和不确定性的存在，导致分布式系统很容易存在一些微妙的 bug。除非使用形式化方法，否则我们只能依赖测试来验证系统的正确性。&lt;/p>
&lt;p>通过 Linearizability 这样一种一致性模型，我们可以基于一种顺序的规格形式地确定并发操作的正确性。在一个 linearizable 的系统中，每个操作看起来是在调用和回复之间的某个时间点原子、瞬间执行。可线性化可以被视作强一致性的同义词。&lt;/p>
&lt;blockquote>
&lt;p>Definition of linearizability:&lt;/p>
&lt;p>Execution history is linearizable if there exists a total order of the operations in the history that matches real time for non-concurrent requests. Each read sees the value of the most recent write in order.&lt;/p>
&lt;/blockquote>
&lt;p>下图所示的执行历史是可线性化的：&lt;/p>
&lt;p>&lt;img src="./image-20231001151607479.png" alt="image-20231001151607479">&lt;/p>
&lt;p>而下图则不是：&lt;/p>
&lt;p>&lt;img src="./image-20231001151618755.png" alt="image-20231001151618755">&lt;/p>
&lt;p>我的理解是 Linearizability 是从外部观测获得的一种性质，它并没有说明具体的实现。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>Raft 论文&lt;/li>
&lt;li>&lt;a href="https://pdos.csail.mit.edu/6.824/papers/raft-faq.txt">6.824 Raft FAQ&lt;/a>&lt;/li>
&lt;/ul>
- https://blog.coherence.codes/posts/2023/mit_6.824_2_raft/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>git 入门</title><link>https://blog.coherence.codes/posts/2023/git_%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 18 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/git_%E5%85%A5%E9%97%A8/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/git_%E5%85%A5%E9%97%A8/ -&lt;p>本文的大部分内容来自于 &lt;a href="https://git-scm.com/book/en/v2">Pro Git&lt;/a> 这本书。&lt;/p>
&lt;h2 id="objects">Objects&lt;/h2>
&lt;p>git 中最基础的元素是 object，每个 object 由一个 object ID (OID) 唯一标识，OID 是一个 160 bits （用 hex 字符串表示为四十个字符） 的 SHA-1 哈希。具体而言，git 中主要存在三种 objects：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>blobs&lt;/code>: 存储文件内容，OID 即为文件内容的哈希&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>trees&lt;/code>: 一个文件名（path entries）的有序列表，OID 为这个列表的哈希。列表的每一行如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>100644 blob 1fc4aa8f76027dd0fb8f9b533810770236d5c234 .gitignore
&lt;/code>&lt;/pre>&lt;p>容易推测这几个字段分别为权限、object 类型、哈希、文件名。子目录同样是 trees。项目的根目录即为 root tree。所有的 trees 构成了一棵 Merkle tree，&lt;del>所以 git 就是区块链（即答&lt;/del>。下图中三角代表 trees，方块为 blobs&lt;/p>
&lt;p>&lt;img src="./image-20230918111328708.png" alt="image-20230918111328708">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>commits&lt;/code>: 一个&lt;strong>快照&lt;/strong>（snapshot），每个 commit 包含了一个到根 tree 的引用，和一个（或多个）到 parent 的引用。parent 就是上一个 commit 的 OID。在一个 merge commit 中会包含多个 parents。由于 Commit 存储的是快照而不是 diff，所以 Git checkout（切换分支）的速度很快。下图中圆形代表 commits&lt;/p>
&lt;p>&lt;img src="./image-20230918111515508.png" alt="image-20230918111515508">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>objects 的特性决定了它们是不可变的，一旦修改了某个 object 中的内容，哈希将会改变，因而会生成一个新的 object.&lt;/p>
&lt;p>可以使用 &lt;code>git cat-file -t&lt;/code> 来检查一个 object 的类型，用 &lt;code>git cat-file -p&lt;/code> 来打印其内容，以本博客的 git 仓库为例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit 10142e0fb1f636288c7f5a6a164e67c1efc13ef4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Author: Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Date: Tue Sep &lt;span style="color:#ae81ff">5&lt;/span> 17:30:57 &lt;span style="color:#ae81ff">2023&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> The Google File System
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -t 10142e0fb1f636288c7f5a6a164e67c1efc13ef4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -p 10142e0fb1f636288c7f5a6a164e67c1efc13ef4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tree f1f161d92d0c7341ed35e76a66855383334005ab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parent 0e72a3f169a8bbc80904ab7750d3c37853a31dc7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>author Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1693906257&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>committer Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1693906257&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgsig -----BEGIN PGP SIGNATURE-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;omitted&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -----END PGP SIGNATURE-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The Google File System
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -p f1f161d92d0c7341ed35e76a66855383334005ab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">040000&lt;/span> tree 9a76f18c0bca57de0ecf8b9bf15e0e9b7adf5621 .github
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100644&lt;/span> blob 1fc4aa8f76027dd0fb8f9b533810770236d5c234 .gitignore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100644&lt;/span> blob 0b47f42f9ec57c58c474dc1f335e14163dd7a549 .gitmodules
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">040000&lt;/span> tree f5b1aa13654d360771df3da98296ac958d537d88 archetypes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100644&lt;/span> blob 8c082a36fd3b90a9e77ec19b17deceb47665e4c7 config.toml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">040000&lt;/span> tree 81200165da89a43766f03762e4a8d8443357f1ed content
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">040000&lt;/span> tree 336e0cfa73193fc3f76ba2b2de182e82b010f599 themes
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这些 objects 都被存在项目的 &lt;code>.git/objects&lt;/code> 目录下，由 SHA-1 的前两个字符作为子目录的文件名，后 38 个字符为 object 的文件名。这些 objects 使用 zlib 压缩，根据 &lt;a href="https://unix.stackexchange.com/questions/22834/how-to-uncompress-zlib-data-in-unix">stackoverflow 上的魔法&lt;/a>，可以用 gzip 来解压这些文件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ ll .git/objects/10/142e0fb1f636288c7f5a6a164e67c1efc13ef4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-r--r--r-- &lt;span style="color:#ae81ff">1&lt;/span> cjc cjc &lt;span style="color:#ae81ff">833&lt;/span> Sep &lt;span style="color:#ae81ff">5&lt;/span> 17:30 .git/objects/10/142e0fb1f636288c7f5a6a164e67c1efc13ef4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ printf &lt;span style="color:#e6db74">&amp;#34;\x1f\x8b\x08\x00\x00\x00\x00\x00&amp;#34;&lt;/span> | cat - .git/objects/10/142e0fb1f636288c7f5a6a164e67c1efc13ef4 | gzip -dc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit 1098tree f1f161d92d0c7341ed35e76a66855383334005ab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parent 0e72a3f169a8bbc80904ab7750d3c37853a31dc7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>author Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1693906257&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>committer Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1693906257&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gpgsig -----BEGIN PGP SIGNATURE-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;omitted&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -----END PGP SIGNATURE-----
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>The Google File System
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gzip: stdin: unexpected end of file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ printf &lt;span style="color:#e6db74">&amp;#34;\x1f\x8b\x08\x00\x00\x00\x00\x00&amp;#34;&lt;/span> | cat - .git/objects/10/142e0fb1f636288c7f5a6a164e67c1efc13ef4 | gzip -dc &amp;gt; test.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gzip: stdin: unexpected end of file
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sha1sum test.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>10142e0fb1f636288c7f5a6a164e67c1efc13ef4 test.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SHA-1 与 commit 的 OID 一致。&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;p>objects 虽然简洁明了，但是它的名字太不好记了。所以 git 引入了 references (或 refs) 作为对某个 object 的引用，它们被存储在 &lt;code>.git/refs&lt;/code> 中，这就是分支。我们可以通过 &lt;code>git update-ref refs/heads/xxxx hash&lt;/code> 来更新/新建一个 ref，&lt;code>git branch&lt;/code> 命令基本等同于使用 &lt;code>update-ref&lt;/code> 创建一个指向当前分支最后一个 commit 的 ref。&lt;/p>
&lt;p>git 通过一个特殊的 HEAD 文件来获得当前分支最后一个 commit 的信息，通常情况下 HEAD 是对某个 ref 的引用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ cat .git/HEAD
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ref: refs/heads/source_hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是当我们 checkout 一个 tag/commit/远程分支时，我们就会进入到所谓的 &amp;ldquo;detached HEAD&amp;rdquo; 状态：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git checkout f25ea89160baa34af6587ebc4399cba9b82152ab
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Note: switching to &lt;span style="color:#e6db74">&amp;#39;f25ea89160baa34af6587ebc4399cba9b82152ab&amp;#39;&lt;/span>.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>You are in &lt;span style="color:#e6db74">&amp;#39;detached HEAD&amp;#39;&lt;/span> state. You can look around, make experimental
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>changes and commit them, and you can discard any commits you make in this
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>state without impacting any branches by switching back to a branch.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>If you want to create a new branch to retain commits you create, you may
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span> so &lt;span style="color:#f92672">(&lt;/span>now or later&lt;span style="color:#f92672">)&lt;/span> by using -c with the switch command. Example:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> git switch -c &amp;lt;new-branch-name&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Or undo this operation with:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> git switch -
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Turn off this advice by setting config variable advice.detachedHead to false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HEAD is now at f25ea8916 fix: Add CHANGELOG link
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这种状态作出的 commits 将成为 dangling commits，因为没有 refs 能够间接引用到它们。我们可以在 &lt;code>git reflog&lt;/code> 中看到它们，但它们在一段时间后可能会被 git 垃圾回收掉。如果因为误操作“丢失”了一些 commit，大部分情况下只是没有 ref 能够间接引用它们了，所以我们能在 reflog 中找到并恢复它们。&lt;/p>
&lt;p>除了分支之外，另一种 ref 是 tag。tag 被存储在 &lt;code>.git/refs/tags&lt;/code> 中，和 branch 不同的是，tag 是不可变的。git 中有两种类型的 tag：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>lightweight tag: 使用 &lt;code>git tag&lt;/code> 创建，其 ref 直接指向一个 commit&lt;/p>
&lt;/li>
&lt;li>
&lt;p>annotated tag: 使用 &lt;code>git tag -a&lt;/code> 创建，需要像 commit 一样写一段 tag message，其 ref 指向 git 中的第四种 object 类型，tag。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git tag -a v1.2.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cat .git/refs/tags/v1.2.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>295e429586c0dc7764077b7ec3b15402b9299532
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -t 295e429586c0dc7764077b7ec3b15402b9299532
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -p 295e429586c0dc7764077b7ec3b15402b9299532
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>object 0996cddadea886287fd606b4102304814eb3785c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>type commit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tag v1.2.3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tagger Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1695018502&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>xxxxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ &lt;span style="color:#75715e"># object 字段就是对 commit 的引用&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -t 0996cddadea886287fd606b4102304814eb3785c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>commit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是 tag 并不是必须指向一个 commit，tag 任何 object 都是可以的。虽然在实践中好像 tag 非 commit 并没有什么用..&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git tag -a tree-tag 9ff1e32671b9ac918dd665020c8da93c44787e33
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cat .git/refs/tags/tree-tag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3b94c91c60f92b16336050aa445c7a293e61ec2e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git cat-file -p 3b94c91c60f92b16336050aa445c7a293e61ec2e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>object 9ff1e32671b9ac918dd665020c8da93c44787e33
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>type tree
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tag tree-tag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tagger Harold Cheng &amp;lt;niuchangcun@gmail.com&amp;gt; &lt;span style="color:#ae81ff">1695018786&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a tag &lt;span style="color:#66d9ef">for&lt;/span> tree
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="merge-and-rebase">Merge and Rebase&lt;/h2>
&lt;p>最简单的 merge 类型是 fast-forward，git 简单地移动 ref 来完成 merge。另一种常见的 merge 如图所示：&lt;/p>
&lt;p>&lt;img src="./basic-merging-1.png" alt="Three snapshots used in a typical merge">&lt;/p>
&lt;p>我们想要在 master 分支上执行 &lt;code>git merge iss53&lt;/code>，git 会找到三个 commits，C5、C4 和它们的共同祖先 C2，然后执行&lt;a href="https://stackoverflow.com/questions/4129049/why-is-a-3-way-merge-advantageous-over-a-2-way-merge">三方合并&lt;/a> (three-way merge)，high-level 地看，git 需要把每个 commit 的 tree 划分成一个一个 chunk，chunk 可以是文件，或文件的一块，或行，这由具体的 merge 策略决定。git 会比较这些 chunks，对于某一个 chunk：&lt;/p>
&lt;ul>
&lt;li>如果在 C2、C4、C5 中都相等，则不作更改&lt;/li>
&lt;li>如果 C2、C4 相等，但和 C5 不等，取 C5 的版本，反之同理&lt;/li>
&lt;li>如果 C4、C5 相等，和 C2 不等，那么两个分支作了同样的更改，取任何一个版本&lt;/li>
&lt;li>如果三者都不相等，则发生 merge 冲突，需要手动处理&lt;/li>
&lt;/ul>
&lt;p>如果我们不寻找 C2，只比较 C4、C5，这就是所谓的 two-way merge，由于失去了祖先的信息，我们无法处理第二种情况。实际进行 merge 时，我们可能会看到如下信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git merge b1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Auto-merging 1.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Merge made by the &lt;span style="color:#e6db74">&amp;#39;ort&amp;#39;&lt;/span> strategy.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1.txt | &lt;span style="color:#ae81ff">1&lt;/span> +
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> file changed, &lt;span style="color:#ae81ff">1&lt;/span> insertion&lt;span style="color:#f92672">(&lt;/span>+&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个过程中，git 会创建一棵新 tree，把两个分支作为 parent 创建一个新的 commit，这就是 merge commit。&lt;/p>
&lt;p>rabase 则是完全不同的方式。如果 cherry-pick 一个 commit：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ git cherry-pick 2f6c412
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>master 2aa02d0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Date: Tue Sep &lt;span style="color:#ae81ff">19&lt;/span> 16:32:32 &lt;span style="color:#ae81ff">2023&lt;/span> +0800
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> file changed, &lt;span style="color:#ae81ff">1&lt;/span> insertion&lt;span style="color:#f92672">(&lt;/span>+&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>本质上是 diff 2f6c412 和 2f6c412 的 parent，然后在当前分支重新应用这个 diff。rebase 本质上是自动的 cherry-pick。&lt;/p>
&lt;p>&lt;img src="./basic-rebase-1.png" alt="Simple divergent history">&lt;/p>
&lt;p>在 experiment 分支执行 &lt;code>git rebase master&lt;/code> 则会找到 experiment 和 master 的共同祖先 C2，然后发现 experiment 分支有一个新的 commit C4，git 会在 master 重做这个 commit。&lt;/p>
&lt;h2 id="一个-fsck-导致的问题">一个 fsck 导致的问题&lt;/h2>
&lt;p>某日我在检查软件更新时，发现 KeePassDX f-droid 版没有随着上游更新，进而发现了&lt;a href="https://github.com/Kunzisoft/KeePassDX/issues/1333">这个 issue&lt;/a>，问题的原因是 KeePassDX 的仓库中有几个 tree object 不合法，运行 &lt;code>git fsck&lt;/code> 会报错 &lt;code>error in tree b7a0b493966f9077f6fcd7de37244699bb73615e: duplicateEntries: contains duplicate file entries&lt;/code>。&lt;/p>
&lt;p>git 不允许一个 tree 中含有两个相同的文件名，但是不知为何这个错误发生了（包含这个 tree 的 commit 可以追溯到 2009 年，可能是由于 Windows 不区分文件名大小写且在上古时期 git 处理这个的逻辑有问题）。而 f-droid 在几个月前启用了 git clone 时的 fsck 检查（&lt;code>transfer.fsckObjects&lt;/code> 等配置），导致 build 时 clone 仓库失败。顺便一提 Github push 现在也有 git fsck 检查，所以把这个仓库往另一个仓库 push 也会失败。&lt;/p>
&lt;p>fsck 失败的问题在多个仓库出现过，包括&lt;a href="https://github.com/highlightjs/highlight.js/issues/1733">highlight.js&lt;/a>, &lt;a href="https://github.com/Behat/Behat">Behat&lt;/a>, &lt;a href="https://github.com/psf/requests/issues/2690">requests&lt;/a>，无一例外都能追溯到某些上古 commit，目前看来除了重写所有 commits 并没有什么办法来修复这些错误。我尝试了 &lt;a href="https://stackoverflow.com/questions/10931954/git-tree-contains-duplicate-file-entries">replace 的魔法&lt;/a>发现并不能够使其通过 git fsck（毕竟出错的 tree 还在）。&lt;/p>
&lt;p>回到 KeePassDX 的问题只能让 f-droid 在 clone 的时候做一些 workaround 来绕过了&amp;hellip;&lt;/p>
- https://blog.coherence.codes/posts/2023/git_%E5%85%A5%E9%97%A8/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>MIT 6.824 学习笔记(一) GFS</title><link>https://blog.coherence.codes/posts/2023/mit_6.824_1_gfs/</link><pubDate>Tue, 05 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/mit_6.824_1_gfs/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/mit_6.824_1_gfs/ -&lt;p>存储系统通常是一个分布式系统的基石，通常应用可以是无状态的，而所有状态便由存储系统来管理。&lt;/p>
&lt;p>Google 文件系统（The Google File System, GFS）在 2003 年于一篇同名论文中被提出，发表在系统领域顶会 SOSP 上，是 Google 大数据三驾马车之一&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。GFS 是一个成功的系统，在 00 年代早期，人们对于分布式文件系统已经有很好的理解了，但是尚未有一个可以扩展到上千个节点的系统被实现出来。很多 GFS 的设计被 HDFS 等后来的分布式文件系统上。&lt;/p>
&lt;p>GFS 基于以下几个方面的观察：&lt;/p>
&lt;ul>
&lt;li>节点故障是常见的，因为其运行在大量普通机器（commodity components）上&lt;/li>
&lt;li>存储的文件以大文件（数百 MB 到数 GB）为主，小文件应当被支持，但不应对其优化&lt;/li>
&lt;li>对文件的大多数写入操作是追加 （append）而不是覆盖/随机写，大多数读取操作是顺序读 （1 MB 或更多）
&lt;ul>
&lt;li>所以系统必须有良好的并发追加操作的语义&lt;/li>
&lt;li>工作负载通常是批处理任务，所以高吞吐量比低延时重要&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>同时设计应用和文件系统 API 有利于整个系统的灵活性&lt;/li>
&lt;/ul>
&lt;h2 id="架构">架构&lt;/h2>
&lt;p>&lt;img src="./image-20230901145431686.png" alt="image-20230901145431686">&lt;/p>
&lt;p>GFS 采用 Master/Slave 架构，集群中存在一个 master 和多个 chunkservers，并且被多个 clients 访问。（由于单 master 的存在，GFS 存在单点故障的可能性，虽然 master 同样有备份，但恢复可能需要人工干预）一个文件将被分割成多个 chunk。chunk 的特性如下：&lt;/p>
&lt;ul>
&lt;li>固定大小，Google 的选择是 64 MB，这么大的 chunk 将有如下好处：
&lt;ul>
&lt;li>减少 client 和 master 的通信，因为在获取到 chunk 的信息后，client 只需要和 chunkserver 交互进行读写&lt;/li>
&lt;li>减少 metadata 的尺寸，以便所有 metadata 可以保存在内存中&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>作为一个普通的 Linux 文件存储在 chunkserver 上&lt;/li>
&lt;li>每个 chunk 由一个不可变的、唯一的 64 位 chunk handle 标记，其由 master 在 chunk 创建时指定
&lt;ul>
&lt;li>chunkserver 根据 chunk handle 和偏移（byte range）来读写 chunk&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>为了可靠性，每个 chunk 会被复制到多个 chunkservers 上 （通常为三个）&lt;/li>
&lt;/ul>
&lt;p>master 管理了所有的元数据，用 Go 代码大概表示为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">ChunkHandle&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Handle&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ChunkServers&lt;/span> []&lt;span style="color:#a6e22e">ChuckServer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">ReplicaNum&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Version&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#75715e">// 为了区分数据是否是最新的
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">Primary&lt;/span> &lt;span style="color:#a6e22e">ChuckServer&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">LeaseExpiration&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Time&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Master&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Files&lt;/span> &lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#a6e22e">Filename&lt;/span>][]&lt;span style="color:#a6e22e">ChunkHandle&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除此之外，还需要 log 和 checkpoint 机制来持久化元数据。元数据中 Handle, ReplicaNum 和 Version 应该是非易失的（non-volatile)。没有持久化 ChunkServers 字段可能是因为 chunkserver 会经常变动。&lt;/p>
&lt;h2 id="一致性模型">一致性模型&lt;/h2>
&lt;p>GFS 采用了一种宽松的一致性模型，不同于 Raft 等强一致性协议，其允许不一致的情况出现。不一致的情况将由应用处理。这实际上是为了性能而牺牲了一些一致性。&lt;/p>
&lt;p>&lt;img src="./image-20230901182949527.png" alt="image-20230901182949527">&lt;/p>
&lt;p>对于一个文件区域，GFS 定义了几种状态：&lt;/p>
&lt;ul>
&lt;li>一致的（consistent）：无论从哪个 replica 读，所有 clients 都会看到同样的数据&lt;/li>
&lt;li>确定的（defined）：在一次写入之后，数据是一致的，并且 clients 都能完整看到这次写入写了什么。&lt;/li>
&lt;li>不一致的（inconsistent）：不同的 client 能够读到不一样的结果&lt;/li>
&lt;/ul>
&lt;p>这三种状态发生于以下情况：&lt;/p>
&lt;ul>
&lt;li>当没有并发写的写入成功后，这块区域就是确定的&lt;/li>
&lt;li>当若干写入操作并发成功后，这块文件区域是不确定但一致的：所有 clients 都能看到同样的数据，但这块可能不能反映出其中任何一次写入的结果（通常是这几次写入的结果交织在一起）&lt;/li>
&lt;li>失败的写入使得这块区域不一致&lt;/li>
&lt;/ul>
&lt;p>GFS 中的写入（mutation）分为指定偏移量的写入（Write）和记录末尾追加（Record Append），record append 能够保证原子的至少一次（at least once）追加，但是有小概率会出现 padding 或者重复数据。GFS 的应用可以通过在每条记录后加入校验来处理不完整的记录，还可以通过加入唯一的标识符来处理重复记录。GFS 的客户端库中包含了这些通用的处理不一致的功能。&lt;/p>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>GFS 使用租约（lease）来维护一个一致的写入顺序（consistent mutation order）。租约就是在一段时间内，master 让某一 replica 成为 primary，master 将保证在这段时间内不会分配另一个 primary，而 primary 将保证在租约过期后不再履行 primary 的职责。primary 将指定一个 chunk 的写入顺序，其他的 replica 则跟随 primary 的顺序。&lt;/p>
&lt;h3 id="写入">写入&lt;/h3>
&lt;p>&lt;img src="./image-20230905110612114.png" alt="image-20230905110612114">&lt;/p>
&lt;p>client 首先向 master 请求 primary 和其他 replicas 的位置。如果尚未有一个 primary，master 会首先增大版本号并通知所有 replicas，然后选定一个 primary 并向其分配租约。client 会缓存这些元数据，以减少 master 的负载。&lt;/p>
&lt;p>client 随后向所有 replica 推送数据，数据被存储在 chunkserver 的本地缓存中等待被使用。数据流和控制流是分离的，这是为了更有效地利用网络。数据流采用了一种流水线的形式，首先 client 向距离其最近的 chunkserver 推送数据，这个 chunkserver 再向其最近的 chunkserver 转发，链式地发送数据，转发不会等待 chunk 传输完而是立即开始的。&lt;/p>
&lt;p>当所有 repicas 都 ACK 收到了数据之后，client 向 primary 请求写入。由于可能存在并发，primary 为所有写入分配一个序列号，在本地应用这些写入，并转发写入请求到其他 replicas。所有 replicas 都 ACK 之后，primary 向 client 回复。如果任何一个 replica 出错，那么被修改的区域就处于不一致的状态，此时由 client 来负责重试失败的写入。（如果在 primary 就出错的话，那么它不会转发写入请求，此时数据应该仍然处于一致的状态）&lt;/p>
&lt;p>当应用写入的区域很大时，GFS client 会将其切分成一个一个 chunk，并分为多个写入操作来执行，此时如果有并发操作，则会出现一致但不确定的状态。&lt;/p>
&lt;h3 id="记录追加record-append">记录追加（Record Append）&lt;/h3>
&lt;p>此操作中 client 只指定文件而不指定偏移，GFS 保证该操作在 GFS 指定的偏移处原子地完成至少一次，并向客户端返回这个偏移。GFS 的应用中有很多是多生产者/单消费者模型，很适合使用记录追加操作。&lt;/p>
&lt;p>记录追加操作和写入大致相同，惟 primary 会检查要追加的数据是否会超出当前 chunk，如果会的话，它将 pad 这个 chunk 到 64MB，指示其他 replicas 也这么操作，并指示客户端重试。（记录追加操作限制最大数据大小为四分之一个最大 chunk size 以便控制碎片的大小）如果没有超出，则按写入的流程进行，此时 primary 会选择一个 offset （即它所认为的文件末尾）告知其他 replicas 进行写入。如果任何一个 replica 失败，客户端会重试操作。这种情况下部分 replica 将会出现重复的记录，但是数据肯定以某一偏移写入了所有 replicas。&lt;/p>
&lt;h2 id="问题">问题&lt;/h2>
&lt;ul>
&lt;li>如果 chunk 的版本号只在分配租约是增加的话，假设一个 replica （非 primary）在某一时刻挂了，因此错过了几个写入，如果版本号此时不改变的话，在那个 replica 恢复之后，client 就会读到过时数据了。论文里好像也没提这种情况怎么处理..&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>以上并未包含论文的完整内容。GFS 我早在去年夏天就开始学了，然后就一直搁置在一旁，直到这两天才重新拿起来&amp;hellip;&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;p>本文的内容来源于：&lt;/p>
&lt;ul>
&lt;li>GFS 论文&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=EpIgvowZr00&amp;amp;t=1935s">6.824 Lecture 3: GFS&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mr-dai.github.io/gfs/">Google File System 总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>另外两篇论文是 MapReduce: Simplified Data Processing on Large Clusters 和 Bigtable: A Distributed Storage System for Structured Data&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div>
- https://blog.coherence.codes/posts/2023/mit_6.824_1_gfs/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>神秘的自动关闭显示器失效问题</title><link>https://blog.coherence.codes/posts/2023/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/ -&lt;h2 id="问题">问题&lt;/h2>
&lt;p>我的桌面环境为 KDE/X11，我在 KDE 的 Power Management 设置中设置了 &lt;code>Screen Energy Saving: Switch off after 5 min&lt;/code>，这个选项时不时地出问题，表现为刚开机时能够正常工作，在闲置五分钟后关闭显示器，但在一段时间过后就不行了，这个一段时间可长可短。重启电脑又能重新工作，而锁屏后也能够正常工作。这个问题从我用 KDE 开始就一直困扰着我，时至今日。&lt;/p>
&lt;h2 id="排查">排查&lt;/h2>
&lt;p>KDE 的电源管理由 powerdevil 控制，其作为 &lt;code>plasma-powerdevil.service&lt;/code> 用户服务运行，查询日志发现有一些神秘的 &lt;code>org_kde_powerdevil[1310]: QObject::disconnect: Unexpected nullptr parameter&lt;/code> 报错，之后证实该报错与本问题无关。&lt;/p>
&lt;p>查看该 &lt;code>.service&lt;/code> 文件发现其使用 &lt;code>Type=dbus&lt;/code> 的启动类型，并且获得了一个叫 &lt;code>org.kde.Solid.PowerManagement&lt;/code> 的 bus name。用 QBBusViewer 可以看到 powerdevil 还提供了 &lt;code>org.freedesktop.PowerManagement&lt;/code> 这一服务。&lt;/p>
&lt;p>查阅 powerdevil 源码以 &lt;code>Switch off after&lt;/code> 为关键词进行搜索可发现相关逻辑位于 &lt;code>daemon/actions/bundled/dpms.cpp&lt;/code> 文件下，根据名字猜测 dpms 即 Display Power Management Signaling 的缩写。简单看了一下 dpms，这是一个古老的协议，在 1993 年发布，定义了四种模式，但 &lt;a href="https://wiki.archlinux.org/title/Display_Power_Management_Signaling">archwiki 上&lt;/a>指出：&lt;/p>
&lt;blockquote>
&lt;p>Note that DPMS was developed for CRT monitors, and on LCD displays, there is normally no difference between the standby, suspend and off modes.&lt;/p>
&lt;/blockquote>
&lt;p>顺便插一句，流传甚广的关闭显示器的命令 &lt;code>xset dpms force off&lt;/code> 即强制 dpms 进入 off 模式。&lt;/p>
&lt;p>在 &lt;a href="https://invent.kde.org/plasma/powerdevil/-/blob/master/daemon/actions/bundled/dpms.cpp#L108">dpms.cpp#L108&lt;/a> 发现在一定条件下空闲超时关闭显示器的函数会直接返回，猜测这个 inhibit 的条件是由上述的两个 dbus 服务来控制的。&lt;/p>
&lt;p>尝试调用上述 dbus 服务：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ qdbus --literal org.kde.Solid.PowerManagement /org/kde/Solid/PowerManagement/PolicyAgent org.kde.Solid.PowerManagement.PolicyAgent.ListInhibitions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Argument: a&lt;span style="color:#f92672">(&lt;/span>ss&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{[&lt;/span>Argument: &lt;span style="color:#f92672">(&lt;/span>ss&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/usr/lib/chromium/chromium&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Capturing&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span>, &lt;span style="color:#f92672">[&lt;/span>Argument: &lt;span style="color:#f92672">(&lt;/span>ss&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/usr/lib/chromium/chromium&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Capturing&amp;#34;&lt;/span>&lt;span style="color:#f92672">]}]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ qdbus --literal org.kde.Solid.PowerManagement /org/freedesktop/PowerManagement org.freedesktop.PowerManagement.Inhibit.HasInhibit
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>发现疑似是 chromium 在 Inhibit，结合阻止理由，很容易想到是我用的&lt;a href="https://chrome.google.com/webstore/detail/imhcgcnjkibjikdbdgnhclihigkooeaf">音量插件&lt;/a>导致的，其原理就是 Capture 当前页面而获得一个相关的音频 API。在关闭了相应标签页之后问题解决。&lt;/p>
&lt;h2 id="疑问">疑问&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;code>org.freedesktop.PowerManagement&lt;/code> API 似乎并没有成为标准，虽然似乎主流的桌面环境都实现了。用 Google 搜索只能搜索到&lt;a href="https://www.freedesktop.org/wiki/Specifications/power-management-spec/">这个页面&lt;/a>，提示：&lt;/p>
&lt;blockquote>
&lt;p>This spec is considered obsolete.&lt;/p>
&lt;/blockquote>
&lt;p>并且页面中 &lt;code>The Spec&lt;/code> 下的链接全都 404 了，另有一个相关的 dbus API &lt;code>org.freedesktop.ScreenSaver&lt;/code>，不知道他们之间的关系是什么。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通常在任务栏的 Power Management 选项卡下会提示哪个应用程序在阻止锁屏，如图所示：&lt;/p>
&lt;p>&lt;img src="./image-20230903202406468.png" alt="image-20230903202406468">&lt;/p>
&lt;p>但是这个提示有时候会不工作&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="workaround">Workaround&lt;/h2>
&lt;p>根据上述描述，这根本不是 bug 而是 feature，但我又时常会使用 chromium 的音量插件，有没有办法绕过呢？&lt;/p>
&lt;p>我尝试手动设置 &lt;code>xset dpms 20 20 20&lt;/code> 并禁用 &lt;code>plasma-powerdevil.service&lt;/code>, 发现在 chromium 没有进行 capture 时 20s 后显示器关闭，而进行 capture 时则不行，怀疑 chromium 除了 &lt;code>org.freedesktop.PowerManagement&lt;/code> dbus API 之外还有其他手段来控制电源管理。&lt;/p>
&lt;p>目前就先不管这个问题了&amp;hellip;&lt;/p>
- https://blog.coherence.codes/posts/2023/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item><item><title>强制 chromium 使用浅色模式</title><link>https://blog.coherence.codes/posts/2023/%E5%BC%BA%E5%88%B6-chromium-%E4%BD%BF%E7%94%A8%E6%B5%85%E8%89%B2%E6%A8%A1%E5%BC%8F/</link><pubDate>Tue, 30 May 2023 00:00:00 +0000</pubDate><guid>https://blog.coherence.codes/posts/2023/%E5%BC%BA%E5%88%B6-chromium-%E4%BD%BF%E7%94%A8%E6%B5%85%E8%89%B2%E6%A8%A1%E5%BC%8F/</guid><description>Coherence's Blog https://blog.coherence.codes/posts/2023/%E5%BC%BA%E5%88%B6-chromium-%E4%BD%BF%E7%94%A8%E6%B5%85%E8%89%B2%E6%A8%A1%E5%BC%8F/ -&lt;h2 id="问题">问题&lt;/h2>
&lt;p>从前两年开始深色模式大行其道，以至于现在几乎找不到一个不支持深色模式的网站了。各大主流浏览器几乎都在两三年前就支持了 CSS 的 &lt;code>prefers-color-scheme&lt;/code> 媒体查询，从而根据系统/浏览器的主题来自动切换浅/深色模式。在浏览器控制台中使用 &lt;code>window.matchMedia('(prefers-color-scheme: dark)').matches&lt;/code> 即可测试这一 feature。&lt;/p>
&lt;p>我在系统中（KDE, Archlinux）使用深色模式，但我又并不喜欢大多数网站的深色模式，但是许多网站都使用了上述媒体查询来自动切换，导致很多情况下我进入一个网站后第一件事就是把浅色模式给切回来。在 Firefox/Edge 中浏览器设置便提供了深/浅色主题的切换选项，这一选项也是和上述媒体查询绑定的，然而不幸的是，chromium 并没有提供这一选项。&lt;/p>
&lt;h2 id="尝试">尝试&lt;/h2>
&lt;p>根据&lt;a href="https://superuser.com/questions/1430098/force-light-mode-in-google-chrome">这个问题&lt;/a>，我尝试安装了一个浅色主题，或者把 theme color 改成浅色，都没有作用。&lt;/p>
&lt;p>那 flags 呢？&lt;code>#enable-force-dark&lt;/code> 提供了强制开启深色模式的选项，但是我在 &lt;code>chrome://flags&lt;/code> 中将其设置为 disabled 之后，并没有发生什么。&lt;a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1046660">Issue 1046660: Allow users to force web content light/dark mode independent of system setting&lt;/a> 中同样提到设置 &lt;code>#enable-force-dark&lt;/code> 为 disabled 将会被忽略。这个 Issue 应该是最贴近我的需求的一个 issue，然而目前还是 open 状态，距离实现遥遥无期。&lt;/p>
&lt;p>另有一个 command line options &lt;code>--disable-features=WebUIDarkMode&lt;/code>，然而遗憾的是这个 option 仅针对 chromium UI, 对 web page 没有作用。&lt;/p>
&lt;p>就在不久之前，chromium 还不支持随系统的深色模式来切换自己的深色模式（见 &lt;a href="https://bugs.chromium.org/p/chromium/issues/detail?id=998903">Issue 998903: XDG Desktop Portal &amp;ldquo;Prefer dark appearance&amp;rdquo; does not affect prefers-color-scheme media query&lt;/a>），这一 feature 是在四月份实现的，并在 114 中发布。从相应的 &lt;a href="https://chromium-review.googlesource.com/c/chromium/src/+/4375982">revision&lt;/a> 中，我们可以发现 chromium 首先会通过 dbus 和 xdg-desktop-portal 交互，读取 &lt;code>org.freedesktop.appearance&lt;/code> namespace 下的 &lt;code>color-scheme&lt;/code> 字段。根据 &lt;a href="https://flatpak.github.io/xdg-desktop-portal/#gdbus-org.freedesktop.portal.Settings">portal 的定义&lt;/a> 返回值是 1 则偏好深色外观，返回值是 2 则偏好浅色外观。并且这一 revision 中说：&lt;/p>
&lt;blockquote>
&lt;pre tabindex="0">&lt;code>* The portal preference takes precedence over the toolkit preference
&lt;/code>&lt;/pre>&lt;/blockquote>
&lt;p>我并没有找到这里的 toolkit 指的是什么，但我猜测是 chromium 自身的主题。这可能就是主题设置无效的原因。KDE 的 portal 由 xdg-desktop-portal-kde 这个包实现，&lt;a href="https://invent.kde.org/plasma/xdg-desktop-portal-kde/-/blob/863d369156c85c67f96a23d87564f196532372ce/src/settings.cpp#L216">搜索源码发现&lt;/a>它只是简单的判断了窗口背景颜色的灰度：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> windowBackgroundGray &lt;span style="color:#f92672">=&lt;/span> qGray(palette.window().color().rgb());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>uint result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// no preference
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (windowBackgroundGray &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">192&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// prefer dark
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// prefer light
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>就感觉很随意&amp;hellip; 所以我在 KDE 设置中更改 Colors 选项中主题的 Window Background 到一个比较浅的背景，就能更改 portal 中的这个值了，试了一下确实是有效的，但是我的其他应用也会变成浅色背景了，这显然不是我想要的。&lt;/p>
&lt;p>&lt;img src="./image-20230530230144145.png" alt="image-20230530230144145">&lt;/p>
&lt;p>我想到了以下几种办法：&lt;/p>
&lt;ul>
&lt;li>hook dbus 请求，给 chromium 返回另一个值，Google 了下没找到什么方法&lt;/li>
&lt;li>让 chromium 的 dbus 请求失败，这样它就会 fallback 到自身的主题设置，同样我并没有找到针对特定应用禁用 dbus 的方法&lt;/li>
&lt;li>patch chromium 源码，这应该是最简单的（显然正确的做法并不简单，只是 hack 的做法简单）&lt;/li>
&lt;li>写一个油猴脚本，在每个网站加载时修改 &lt;code>prefers-color-scheme&lt;/code> 这个媒体查询的返回值，但我没有找到能够在 JS 中修改媒体查询的办法&lt;/li>
&lt;/ul>
&lt;p>最可行的看起来是第三条路了。代价就是长达四个小时的编译时间，以及每次 chromium 更新后都需要重新编译。&lt;/p>
&lt;h2 id="如何-patch">如何 patch&lt;/h2>
&lt;p>如果只是改一个版本的话，直接修改源文件后使用 &lt;code>makepkg -e&lt;/code> 在不重新解压源码的情况下 rebuild 即可。但是版本更新后源码会重新下载，所以还是需要一个 patch 的。我遵循了&lt;a href="https://wiki.archlinux.org/title/Patching_packages">这个 ArchWiki&lt;/a> 来创建一个 patch，但是把源码复制一份实在是太大了，所以我使用 &lt;code>cp --parent&lt;/code> 单独复制了一个文件，然后再 diff：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-patch" data-lang="patch">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">--- chromium-114.0.5735.45/chrome/browser/ui/views/dark_mode_manager_linux.cc 2023-05-25 08:41:45.780152800 +0800
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ new/chrome/browser/ui/views/dark_mode_manager_linux.cc 2023-05-31 12:40:12.308506988 +0800
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -25,7 +25,7 @@
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> constexpr char kReadMethod[] = &amp;#34;Read&amp;#34;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> constexpr char kSettingsNamespace[] = &amp;#34;org.freedesktop.appearance&amp;#34;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> constexpr char kColorSchemeKey[] = &amp;#34;color-scheme&amp;#34;;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">-constexpr int kFreedesktopColorSchemeDark = 1;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+constexpr int kFreedesktopColorSchemeDark = 2;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scoped_refptr&amp;lt;dbus::Bus&amp;gt; CreateBus() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dbus::Bus::Options options;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里改动的是 chromium 从 xdg-desktop-portal 获取到 &lt;code>color-scheme&lt;/code> 之后，判断是否为深色模式的常量，这一改动即可反转 chromium 对于浅/深色模式的判断。&lt;/p>
&lt;p>patch 中第一个文件夹的名字，也就是 &lt;code>chromium-114.0.5735.45&lt;/code> 和 &lt;code>new&lt;/code> 并不重要，因为在 PKGBUILD 中我们会使用 &lt;code>-p1&lt;/code> 来忽略第一个文件夹：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>-p&lt;/strong>num or **&amp;ndash;strip=**num
Strip the smallest prefix containing num leading slashes from each file name found in the patch file.&lt;/p>
&lt;/blockquote>
&lt;p>然后就是编译了，在等待了四个小时之后我终于成功切换回了浅色模式！&lt;/p>
&lt;p>&lt;img src="./image-20230531125453946.png" alt="image-20230531125453946">&lt;/p>
&lt;p>最后还是希望 &lt;a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1046660">Issue 1046660&lt;/a> 能够被尽快解决，让我能够在设置中直接切换浅/暗色模式。&lt;/p>
- https://blog.coherence.codes/posts/2023/%E5%BC%BA%E5%88%B6-chromium-%E4%BD%BF%E7%94%A8%E6%B5%85%E8%89%B2%E6%A8%A1%E5%BC%8F/ - Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</description></item></channel></rss>