<!doctype html><html><head><title>Linux 内存管理初探</title>
<meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/js/toc.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/dark-mode.min.cb53f1bee2b8900cb4f082afbf00175d6618f281cf9a2fe8619e3b52d20b5721.css integrity="sha256-y1PxvuK4kAy08IKvvwAXXWYY8oHPmi/oYZ47UtILVyE=" media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Material+Icons"><script async defer data-domain=blog.coherence.codes src=https://analytics.coherence.space/js/plausible.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><div id=app><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>存档
</a><a class="a-block drawer-menu-item false" href=/tags>标签
</a><a class="a-block drawer-menu-item false" href=/categories>分类
</a><a class="a-block drawer-menu-item false" href=/friends>友链
</a><a class="a-block drawer-menu-item false" href=/about>关于
</a><a class="a-block drawer-menu-item false" href=/index.xml>RSS Feed</a><div class=toc><div class=toc-content><center>- 目录 -</center><ul><ul><li><a href=#%e4%bb%8e%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e5%bc%80%e5%a7%8b%e8%af%b4%e8%b5%b7 class=nav-从虚拟内存开始说起>从虚拟内存开始说起</a></li><li><a href=#page-cache class=nav-page-cache>Page Cache</a></li><li><a href=#vszrss class=nav-vszrss>VSZ/RSS</a></li><li><a href=#free class=nav-free>free</a></li><li><a href=#swap class=nav-swap>swap</a></li><li><a href=#windows class=nav-windows>Windows</a></li><li><a href=#%e5%b0%8f%e6%95%85%e4%ba%8b class=nav-小故事>小故事</a></li><li><a href=#ref class=nav-ref>ref</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu
</i></button>
<a id=navTitle class=navbar-brand href=https://blog.coherence.codes/>Coherence's Blog
</a><button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://blog.coherence.codes/><div class=single-column-header-title>Coherence's Blog</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>Linux 内存管理初探<div class=post-meta><time itemprop=datePublished>2024-09-05 00:00
</time><i class=material-icons>label</i>
<a href=/tags/linux>Linux</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><p>本文试图解释两个简单的问题：<code>free</code> 命令中的 used/free/available 等字段究竟代表了什么？而 <code>ps</code> 命令中的 VSZ/RSS 又代表了什么？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ free -h
</span></span><span style=display:flex><span>               total        used        free      shared  buff/cache   available
</span></span><span style=display:flex><span>Mem:            38Gi        15Gi       834Mi       3.3Gi        25Gi        22Gi
</span></span><span style=display:flex><span>Swap:           19Gi       5.3Gi        14Gi
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ps aux --sort<span style=color:#f92672>=</span>-rss | head -5
</span></span><span style=display:flex><span>USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
</span></span><span style=display:flex><span>cjc         <span style=color:#ae81ff>3354</span>  2.3  4.6 <span style=color:#ae81ff>97222056</span> <span style=color:#ae81ff>1917888</span> ?    Ssl  Oct07  37:42 /usr/bin/qbittorrent
</span></span><span style=display:flex><span>cjc       <span style=color:#ae81ff>354324</span>  1.3  2.7 <span style=color:#ae81ff>2772076</span> <span style=color:#ae81ff>1137784</span> ?     Ssl  12:05   1:59 /usr/bin/telegram-desktop
</span></span><span style=display:flex><span>cjc         <span style=color:#ae81ff>2806</span>  6.6  2.3 <span style=color:#ae81ff>4141220</span> <span style=color:#ae81ff>941484</span> ?      Sl   Oct07 109:17 /usr/bin/kwin_wayland ...
</span></span><span style=display:flex><span>cjc         <span style=color:#ae81ff>3390</span>  1.5  1.9 <span style=color:#ae81ff>3994932</span> <span style=color:#ae81ff>792364</span> ?      Sl   Oct07  26:10 /usr/lib/zotero/zotero-bin ...
</span></span></code></pre></div><p>本文假定读者具有虚拟内存的基础知识，文中的代码将以 C 语言为例。</p><h2 id=从虚拟内存开始说起>从虚拟内存开始说起</h2><p>我们先来复习一下虚拟内存地址转换的流程。</p><p><img src=./image-20240905013733596.png alt=image-20240905013733596>
（图源：CSAPP)</p><p>当程序访问一个虚拟地址时，在汇编层面体现为一条读指令（<code>mov</code> 之类的），由 CPU 中的 MMU 处理地址转换。MMU（Memory Management Unit）首先根据页表基址寄存器（Page Table Base Register, PTBR）的地址加上虚拟地址的页面偏移（也就是虚拟地址的前 x 位）找到页表条目（Page Table Entry, PTE）的地址（这里省略了 TLB 的部分），这个地址当然是物理地址。PTE 中存储了这一页的物理地址，以及标记该页是否在内存中的有效位。如果该页存在内存，那么 CPU 直接访问内存进行读取。如果不存在，则进入缺页异常（page fault）程序，程序由用户态进入内核态。此时程序可能会被阻塞并换出，直到页被读入内存。</p><p>这里我们就要问了，为什么一个页会不在内存呢？在 Linux 中，存在两种情况：</p><ul><li><p>这一页是匿名内存（anonymous memory），它们通常是程序运行时动态分配的内存（比如 C 中的 <code>malloc</code> 函数）。它们没有文件后备，但如果系统中启用了 swap 交换文件，那么它们也能被换出到 swap 中。</p></li><li><p>这一页是 page cache，也就是文件内存（file memory），它们可能是代码（比如 <code>.text</code> 段）或缓存的数据（比如通过 mmap 映射的文件，mmap 是个非常重要的系统调用，下面还会提到）。它们是文件后备的（backed by file），所以能够被换出，或者也被称为回收（reclaim）。</p><p>这里其实还能再细分一下，如果这一页是未修改过的（clean），那么可以直接修改页表有效位，不需要其他操作。如果是修改过的页面（dirty），则需要先将变更写入磁盘后才能回收。（为什么会存在脏页？请看下文）</p></li></ul><h2 id=page-cache>Page Cache</h2><p>那我们为什么需要 Page Cache呢？<a href=https://web.archive.org/web/20221222014954/https://manybutfinite.com/post/page-cache-the-affair-between-memory-and-files/>Page Cache, the Affair Between Memory and Files</a> 这篇非常精彩的文章讲述了 Page Cache。当操作系统开始处理文件时，会碰到两个问题：</p><ul><li>读写磁盘相比于读写内存慢了好几个数量级</li><li>对于一些文件（比如代码和共享库），需要只载入一次，而在多个进程之间共享</li></ul><p>而这两个问题都能被 page cache 解决。正如其名，page cache 就是内核存储的按页大小分割的文件。操作系统将文件缓存在内存中，解决了第一个问题。对于能够共享的文件，操作系统在内存中只存储一份副本，解决了第二个问题。常规的文件读写都会通过 page cache 进行。</p><p>那是不是文件只会存储在 page cache 中呢？当我们读取一个文件时，需要：</p><ul><li>使用 <code>malloc()</code> 分配一块堆内存作为缓冲区，假设为 4K。这块内存是匿名内存。</li><li>使用 <code>open()</code> 打开一个文件获取文件描述符，使用 <code>read()</code> 读取文件到缓冲区。此时内核将读取一个页大小的文件内容存放到 page cache 中，再把 page cache 的内容复制到程序的堆内存上。</li></ul><p>看到问题了吗？一份数据在内存中存了两份！解决这个问题的方式是内存映射文件（Memory-mapped files）。在 Linux 上也就是 <code>mmap</code> 系统调用。mmap 的流程如下：</p><ul><li>使用 <code>mmap()</code> 将一个文件映射到虚拟地址空间中的某一段地址，长度为用户给定。</li><li>直接读取这段地址中的某一个。</li><li>触发常规访存流程。也就是说，如果这个地址所在的页不在内存中，则触发缺页中断把这个页读进内存。</li></ul><p>因为 page cache 的存在，对文件的写入（<code>write()</code> 系统调用）不会马上写入到磁盘。内核会把修改写入到 page cache 中，同时把该页标记为脏（dirty），因此文件写入不会阻塞。</p><p>由于脏页的存在，Linux 需要处理文件（在内存/磁盘中）的一致性。存在两种实现文件一致性的方法：</p><ul><li>Write Through（直写/写穿）：对文件的写入会直接写到磁盘。这是通过 <code>fsync</code>, <code>fdatasync</code> 等系统调用实现的。</li><li>Write back（写回）：对文件的写入暂存在内存。系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块。这是 Linux 的默认行为。</li></ul><p>我们能做个小实验验证这个行为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/meminfo | grep Dirty <span style=color:#75715e># 查看当前脏页大小</span>
</span></span><span style=display:flex><span>Dirty:               <span style=color:#ae81ff>828</span> kB
</span></span><span style=display:flex><span>$ dd <span style=color:#66d9ef>if</span><span style=color:#f92672>=</span>/dev/zero of<span style=color:#f92672>=</span>testfile.txt bs<span style=color:#f92672>=</span>1M count<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>10+0 records in
</span></span><span style=display:flex><span>10+0 records out
</span></span><span style=display:flex><span><span style=color:#ae81ff>10485760</span> bytes <span style=color:#f92672>(</span><span style=color:#ae81ff>10</span> MB, <span style=color:#ae81ff>10</span> MiB<span style=color:#f92672>)</span> copied, 0.00600495 s, 1.7 GB/s
</span></span><span style=display:flex><span>$ cat /proc/meminfo | grep Dirty <span style=color:#75715e># 此时对文件的写入只存在 page cache 中</span>
</span></span><span style=display:flex><span>Dirty:             <span style=color:#ae81ff>10596</span> kB
</span></span><span style=display:flex><span>$ sync <span style=color:#75715e># 刷脏</span>
</span></span><span style=display:flex><span>$ cat /proc/meminfo | grep Dirty
</span></span><span style=display:flex><span>Dirty:               <span style=color:#ae81ff>364</span> kB
</span></span></code></pre></div><p>最后，上文提到了“常规”的文件读写是通过 page cache 进行的，通过在 <code>open()</code> 时使用 <code>O_DIRECT</code> 选项等方法能够绕过 page cache。这就是所谓的 Direct IO，一些数据库会采取这种方法进行 IO，以获取更高的性能。</p><p>一个文件映射可以是私有（private）或者共享（shared）的。</p><ul><li>更新一个共享的文件映射对其他进程可见，同时也会更新到其映射的文件上。</li><li>更新一个私有的文件映射同理，不对其他进程可见，也不会更新到其映射的文件上。</li></ul><p>那如果有两个进程同时映射了一个文件，并且使用了私有映射，这个文件是不是就要在内存中存两份了？当然不会。内核使用了 CoW（copy on write，写时复制）来解决这一问题。</p><p><img src=./copyOnWrite.png alt="The Copy-On-Write mechanism">
（图源：<a href=https://web.archive.org/web/20221222014954/https://manybutfinite.com/post/page-cache-the-affair-between-memory-and-files/>Page Cache, the Affair Between Memory and Files</a>）</p><p><code>render</code> 和 <code>render3d</code> 两个进程私有地 map 了相同的文件，这些页被内核标记成只读（事实上，只读标记并不意味着它们是<strong>只读</strong>的，只是为了区分它们和非 CoW 的页）。<code>render</code> 进程随后修改了一部分文件，由于只读标记的存在，程序访存时将触发 page fault，内核将该页复制一份成为匿名页（因为私有的文件映射并不会实际更新到文件中），并修改页表将原先的虚拟地址指向新的匿名页。随后对该匿名页进行写入。这一机制对应用程序完全透明。</p><p>这一技术也被用在 fork 一个进程时。</p><h2 id=vszrss>VSZ/RSS</h2><p>有了上面的基础知识，就可以说说 VSZ/RSS 了。查询 <code>man top</code> （top 的手册解释得比 ps 更详细）可知：</p><ul><li>VSZ（virtual memory size，虚拟内存大小），或 VIRT（virtual），程序所申请的内存大小。</li><li>RSS （resident set size，常驻集大小？我也不知道怎么翻译），或 RES（resident memory size）进程实际占用的物理内存，也就是那些未被换出的页的大小。</li></ul><p>我们有时候能够见到 VSZ 远大于 RSS，比如这堆申请了几十G内存的 chromium：</p><p><img src=./image-20241012005445767.png alt=image-20241012005445767></p><p>这是因为内核使用了惰性分配（lazy allocation），也就是程序请求内存分配的时候，只分配虚拟地址。程序第一次访问虚拟地址的时候，才分配物理内存。这种做法进一步提高了系统的内存利用率。</p><p>更进一步，Linux 采取了超额分配（overcommit）的方式，也就是程序申请的内存可以大于物理内存+swap 的总数。与之相对，Windows 则并不允许 overcommit，所有程序申请的总内存必须小于物理内存+swap 的总数。</p><p>需要注意的是，RSS 并不能代表程序“需要”的内存，RSS 很大可能仅仅是系统的内存水位不高，不需要的页尚未被回收。比如设想一下一个程序 mmap 了一个 40G 大小的文件，全部读取并进行了一些操作。由于程序之后可能还会用到这个文件，这段内存并没有被 munmap。此时程序的 RSS 为 40G，但是程序可能很久都不会用到这 40G。</p><p>另一个能够反映程序内存占用的指标是 WSS（working set size，工作集大小），也就是一段时间内（比如 10min）程序使用的内存大小。Linux 并没有提供一个很简单的方式读取进程的 WSS，但是使用一些工具能做到这一点，参照<a href=https://www.brendangregg.com/blog/2018-01-17/measure-working-set-size.html>这篇文章</a>。</p><p>上面说到 fork 时内核使用了 CoW，我们可以做一个小实验观察这一点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span> <span style=color:#f92672>*</span> (<span style=color:#66d9ef>size_t</span>)<span style=color:#ae81ff>1024</span>; <span style=color:#75715e>// 10G 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ptr <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(size);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// use 10G memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>memset</span>(ptr, <span style=color:#ae81ff>0</span>, size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> pid <span style=color:#f92672>=</span> <span style=color:#a6e22e>fork</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// do not fork again
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sleep</span>(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=./image-20240905021713812.png alt=image-20240905021713812></p><p>可以看到每个 fork 出来的进程的 RSS 都是 10G，而我的系统并没有 100G 内存。这也从侧面说明了简单将 RSS 相加统计系统的内存用量是不可靠的。</p><p>除了 ps/top，有没有办法能够获得更细节的进程内存信息呢？当然是有的。这就是 <code>/proc/&lt;pid>/maps</code> 和 <code>/proc/&lt;pid>/smaps</code>。smaps 相比比 maps 包含了更详细的信息。通过一个<a href=https://github.com/cjc7373/my_scripts/blob/master/active/parse_proc_smaps.py>简单的 Python 脚本</a>就可以对 smaps 中的信息进行汇总。</p><p>比如看一下 qbittorrent 的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ python parse_proc_smaps.py /proc/2179/smaps
</span></span><span style=display:flex><span><span style=color:#f92672>========================================================================================================================</span>
</span></span><span style=display:flex><span>Private_Clean  Private_Dirty  Shared_Clean  Shared_Dirty         Rss         Pss          VSZ      library
</span></span><span style=display:flex><span><span style=color:#f92672>========================================================================================================================</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>36360</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB    <span style=color:#ae81ff>36360</span> kB    <span style=color:#ae81ff>36360</span> kB    <span style=color:#ae81ff>2274188</span> kB <span style=color:#f92672>[</span>anonymous<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB      <span style=color:#ae81ff>39536</span> kB    <span style=color:#ae81ff>39536</span> kB    <span style=color:#ae81ff>19768</span> kB      <span style=color:#ae81ff>39536</span> kB /memfd:wayland-shm <span style=color:#f92672>(</span>deleted<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>18464</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB    <span style=color:#ae81ff>18464</span> kB    <span style=color:#ae81ff>18464</span> kB      <span style=color:#ae81ff>18508</span> kB <span style=color:#f92672>[</span>heap<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>4764</span> kB anon_inode:i915.gem
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB         <span style=color:#ae81ff>128</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB      <span style=color:#ae81ff>128</span> kB      <span style=color:#ae81ff>128</span> kB        <span style=color:#ae81ff>132</span> kB <span style=color:#f92672>[</span>stack<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>8</span> kB          <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>8</span> kB        <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>8</span> kB <span style=color:#f92672>[</span>vdso<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>0</span> kB         <span style=color:#ae81ff>16</span> kB <span style=color:#f92672>[</span>vvar<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>4</span> kB <span style=color:#f92672>[</span>vsyscall<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>========================================================================================================================</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>2087680</span> kB           <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB  <span style=color:#ae81ff>2087680</span> kB  <span style=color:#ae81ff>2087680</span> kB   <span style=color:#ae81ff>60184244</span> kB /mnt/gloway/TV_Series
</span></span><span style=display:flex><span>     <span style=color:#ae81ff>51900</span> kB           <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB    <span style=color:#ae81ff>51900</span> kB    <span style=color:#ae81ff>51900</span> kB    <span style=color:#ae81ff>5558576</span> kB /mnt/gloway/Documentary
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>52</span> kB           <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>52</span> kB       <span style=color:#ae81ff>52</span> kB    <span style=color:#ae81ff>5302412</span> kB /mnt/gloway/Movies
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>2988</span> kB        <span style=color:#ae81ff>7664</span> kB      <span style=color:#ae81ff>62508</span> kB          <span style=color:#ae81ff>0</span> kB    <span style=color:#ae81ff>73160</span> kB    <span style=color:#ae81ff>13477</span> kB     <span style=color:#ae81ff>366556</span> kB /usr/lib
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB      <span style=color:#ae81ff>19636</span> kB          <span style=color:#ae81ff>0</span> kB    <span style=color:#ae81ff>19636</span> kB      <span style=color:#ae81ff>676</span> kB      <span style=color:#ae81ff>20236</span> kB /usr/share/fonts
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>1440</span> kB         <span style=color:#ae81ff>164</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB     <span style=color:#ae81ff>1604</span> kB     <span style=color:#ae81ff>1604</span> kB      <span style=color:#ae81ff>12584</span> kB /usr/bin
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>4096</span> kB          <span style=color:#ae81ff>0</span> kB     <span style=color:#ae81ff>4096</span> kB       <span style=color:#ae81ff>54</span> kB       <span style=color:#ae81ff>6080</span> kB /usr/lib/locale
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>1976</span> kB          <span style=color:#ae81ff>0</span> kB     <span style=color:#ae81ff>1976</span> kB       <span style=color:#ae81ff>69</span> kB       <span style=color:#ae81ff>3260</span> kB /home/cjc/.cache
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>32</span> kB         <span style=color:#ae81ff>248</span> kB       <span style=color:#ae81ff>1308</span> kB          <span style=color:#ae81ff>0</span> kB     <span style=color:#ae81ff>1588</span> kB      <span style=color:#ae81ff>414</span> kB       <span style=color:#ae81ff>2176</span> kB /usr/lib/qt6
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>52</span> kB           <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>544</span> kB          <span style=color:#ae81ff>0</span> kB      <span style=color:#ae81ff>596</span> kB      <span style=color:#ae81ff>269</span> kB       <span style=color:#ae81ff>1212</span> kB /usr/share/icons
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>444</span> kB          <span style=color:#ae81ff>0</span> kB      <span style=color:#ae81ff>444</span> kB       <span style=color:#ae81ff>16</span> kB        <span style=color:#ae81ff>448</span> kB /var/cache/fontconfig
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB         <span style=color:#ae81ff>80</span> kB          <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>80</span> kB        <span style=color:#ae81ff>3</span> kB        <span style=color:#ae81ff>184</span> kB /usr/share/mime
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>8</span> kB         <span style=color:#ae81ff>36</span> kB          <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>44</span> kB        <span style=color:#ae81ff>8</span> kB         <span style=color:#ae81ff>60</span> kB /usr/lib/libproxy
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB         <span style=color:#ae81ff>28</span> kB          <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>28</span> kB        <span style=color:#ae81ff>0</span> kB         <span style=color:#ae81ff>28</span> kB /usr/lib/gconv
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB         <span style=color:#ae81ff>24</span> kB          <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>24</span> kB        <span style=color:#ae81ff>0</span> kB         <span style=color:#ae81ff>24</span> kB /usr/share/locale
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB         <span style=color:#ae81ff>12</span> kB          <span style=color:#ae81ff>0</span> kB       <span style=color:#ae81ff>12</span> kB        <span style=color:#ae81ff>0</span> kB         <span style=color:#ae81ff>12</span> kB /home/cjc/.local
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>0</span> kB         <span style=color:#ae81ff>12</span> kB /usr/share/qt6
</span></span><span style=display:flex><span>         <span style=color:#ae81ff>0</span> kB           <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>0</span> kB        <span style=color:#ae81ff>0</span> kB          <span style=color:#ae81ff>4</span> kB /var/lib/flatpak
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>2144144</span> kB       <span style=color:#ae81ff>63036</span> kB      <span style=color:#ae81ff>90700</span> kB      <span style=color:#ae81ff>39536</span> kB  <span style=color:#ae81ff>2337416</span> kB  <span style=color:#ae81ff>2230942</span> kB   <span style=color:#ae81ff>73795264</span> kB total
</span></span></code></pre></div><p>这里有一个新概念 PSS（proportional set size），对于每个 RSS 中的页，如果这个页被 n 个进程共享，那么在计算时就把它除以 n。也就是说，如果有一个库 RSS 100k，但是它被 10 个进程共享，那么每个进程的 PSS 就是 10k。</p><p>表中的第二部分展示了内存中文件映射的部分。从中可以看到，qb 的 2.3G RSS 有 2.1G 都是做种的文件（<code>/mnt/gloway</code>），<code>/usr/lib</code> 中的库文件占了 73M，但是由于共享的进程较多，PSS 只有 13M。</p><p>第一部分主要是堆栈的内存。<code>[heap]</code> 和 <code>[anonymous]</code> 实际都是堆内存（也就是通过 malloc 分配的匿名页面），</p><h2 id=free>free</h2><p>那么 free 里的内存占用是怎么计算出来的呢？简单查阅 <code>man free</code> 可知，其数据来源于 <code>/proc/meminfo</code>（<a href=https://github.com/torvalds/linux/blob/master/Documentation/filesystems/proc.rst#meminfo>内核文档</a>），含义如下：</p><ul><li><p>total：物理内存/swap 的总数</p></li><li><p>used：total - available</p></li><li><p>free：未使用的内存</p></li><li><p>cache/buffer：page cache</p><ul><li><blockquote><p>As of the 2.4 kernel, these two caches have been combined. Today, there is only one cache, the Page Cache
<a href=https://www.thomas-krenn.com/en/wiki/Linux_Page_Cache_Basics>https://www.thomas-krenn.com/en/wiki/Linux_Page_Cache_Basics</a></p></blockquote></li></ul></li><li><p>available：对还有多少可用内存的估计。这个字段考虑了系统需要部分 page cache 来工作，并且不是所有可回收的 slab 是可回收的（由于正在被使用的项目）</p></li></ul><p>这里就是一个反直觉的地方了。内核对可用内存的计算仅仅是一个<strong>估计</strong>，内核并不知道确切的“可用”内存的数量。</p><p>在深究之前我们先来说一说内存的水位（watermark）和<a href=https://docs.kernel.org/admin-guide/mm/concepts.html#reclaim>回收</a>。内核把物理内存空间分成多个 Zone，Zone 之间的区别在这里并不重要，可以简单理解为物理内存是所有 Zone 相加。一个 Zone 内的页面除了已用内存页，剩下的就是空闲页（free pages）。空闲页范围中有三个水位线（watermark ）评估当前内存压力情况，分别是高位（high）、低位（low）、最小位（min）。</p><p>如果空闲页面在 low 水位之上，内核什么也不会干。当空闲页低于 low 水位后，内核会唤醒 <code>kswapd</code> 线程。它会异步扫描内存页进行内存回收，直到水位达到 high。如果内存用量进一步升高，空闲页面低于 min 水位，此时内存分配将进入直接回收（direct reclaim）。回收操作将变为同步的，内存分配操作将阻塞直到足够多的页面被回收。</p><p><img src=./640.webp alt=Image>
（图源：<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;mid=2649785631&amp;idx=1&amp;sn=4ff0a18db034174b5dec2455c759e3d8">Linux内存变低会发生什么问题-腾讯技术工程</a>)</p><p>内核的内存回收采取 LRU 算法。当然，有时候程序会比内核有更多的信息，知道哪些页不应该被换出，这时程序可以使用 <code>mlock</code> 等系统调用阻止某些页被换出。</p><p>实践上，内核的内存水位设定非常保守。我们可以通过 <code>/proc/zoneinfo</code> 计算得到。在我的 40G 内存的机器上面：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/zoneinfo
</span></span><span style=display:flex><span>Node 0, zone      DMA
</span></span><span style=display:flex><span>  pages free     <span style=color:#ae81ff>262</span>
</span></span><span style=display:flex><span>        boost    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        min      <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>        low      <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>        high     <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>        spanned  <span style=color:#ae81ff>4095</span>
</span></span><span style=display:flex><span>        present  <span style=color:#ae81ff>3998</span>
</span></span><span style=display:flex><span>        managed  <span style=color:#ae81ff>3840</span>
</span></span><span style=display:flex><span>Node 0, zone    DMA32
</span></span><span style=display:flex><span>  pages free     <span style=color:#ae81ff>212504</span>
</span></span><span style=display:flex><span>        boost    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        min      <span style=color:#ae81ff>621</span>
</span></span><span style=display:flex><span>        low      <span style=color:#ae81ff>996</span>
</span></span><span style=display:flex><span>        high     <span style=color:#ae81ff>1371</span>
</span></span><span style=display:flex><span>        spanned  <span style=color:#ae81ff>1044480</span>
</span></span><span style=display:flex><span>        present  <span style=color:#ae81ff>395943</span>
</span></span><span style=display:flex><span>        managed  <span style=color:#ae81ff>379492</span>
</span></span><span style=display:flex><span>Node 0, zone   Normal
</span></span><span style=display:flex><span>  pages free     <span style=color:#ae81ff>1503321</span>
</span></span><span style=display:flex><span>        boost    <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        min      <span style=color:#ae81ff>16267</span>
</span></span><span style=display:flex><span>        low      <span style=color:#ae81ff>26089</span>
</span></span><span style=display:flex><span>        high     <span style=color:#ae81ff>35911</span>
</span></span><span style=display:flex><span>        spanned  <span style=color:#ae81ff>10024960</span>
</span></span><span style=display:flex><span>        present  <span style=color:#ae81ff>10024960</span>
</span></span><span style=display:flex><span>        managed  <span style=color:#ae81ff>9824396</span>
</span></span></code></pre></div><p>将三个 Zone 的水位相加（单位为页，大小 4KB）：</p><ul><li>min = 6+621+16267 = 66 MB</li><li>low = 9+996+26089 = 106 MB</li><li>high = 12+1371+35911 = 145 MB</li></ul><p>可以看到相比于内存总数几乎可以忽略不计。回到可用内存，我们来看一眼<a href=https://elixir.bootlin.com/linux/v6.11.3/source/mm/show_mem.c#L32>计算 available 的代码</a>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>long</span> available;
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> pagecache;
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> wmark_low <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> reclaimable;
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> zone <span style=color:#f92672>*</span>zone;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 这里就是上文的计算
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>for_each_zone</span>(zone)
</span></span><span style=display:flex><span>    wmark_low <span style=color:#f92672>+=</span> <span style=color:#a6e22e>low_wmark_pages</span>(zone);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Estimate the amount of memory available for userspace allocations,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * without causing swapping or OOM.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 空闲的页
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>available <span style=color:#f92672>=</span> <span style=color:#a6e22e>global_zone_page_state</span>(NR_FREE_PAGES) <span style=color:#f92672>-</span> totalreserve_pages;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Not all the page cache can be freed, otherwise the system will
</span></span></span><span style=display:flex><span><span style=color:#75715e> * start swapping or thrashing. Assume at least half of the page
</span></span></span><span style=display:flex><span><span style=color:#75715e> * cache, or the low watermark worth of cache, needs to stay.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>pagecache <span style=color:#f92672>=</span> <span style=color:#a6e22e>global_node_page_state</span>(NR_ACTIVE_FILE) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>global_node_page_state</span>(NR_INACTIVE_FILE);
</span></span><span style=display:flex><span><span style=color:#75715e>// 加上 page cache, 减去 low 水位的预留
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>pagecache <span style=color:#f92672>-=</span> <span style=color:#a6e22e>min</span>(pagecache <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, wmark_low);
</span></span><span style=display:flex><span>available <span style=color:#f92672>+=</span> pagecache;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Part of the reclaimable slab and other kernel memory consists of
</span></span></span><span style=display:flex><span><span style=color:#75715e> * items that are in use, and cannot be freed. Cap this estimate at the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * low watermark.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 再加上内核中的可回收页
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>reclaimable <span style=color:#f92672>=</span> <span style=color:#a6e22e>global_node_page_state_pages</span>(NR_SLAB_RECLAIMABLE_B) <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>global_node_page_state</span>(NR_KERNEL_MISC_RECLAIMABLE);
</span></span><span style=display:flex><span>reclaimable <span style=color:#f92672>-=</span> <span style=color:#a6e22e>min</span>(reclaimable <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>, wmark_low);
</span></span><span style=display:flex><span>available <span style=color:#f92672>+=</span> reclaimable;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (available <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    available <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> available;
</span></span></code></pre></div><p>对于大内存的机器，由于 low 水位几乎可以忽略，所以 available 约等于空闲的页 + page cache。</p><h2 id=swap>swap</h2><p>swap 并不是所谓的“紧急”内存，只有在物理内存不够时才会使用。如上文所说，swap 的意义在于让匿名内存可以被回收。操作系统总是倾向于用满物理内存，可能有的匿名页很久都不会被使用（比最久的 page cache 还久），那么它们就应当被换出到 swap 中。</p><p>内核参数中的 <code>vm.swappiness</code> 控制在内存回收的时候，是优先回收匿名页面， 还是优先回收文件页面。这个值越高, 回收回收匿名页面的倾向越高。</p><h2 id=windows>Windows</h2><p>Linux 已经讲得够多了，那么 Windows 又是怎样的呢？其实<a href=https://www.zhihu.com/question/43714216/answer/1164044678>大差不差</a>。只是 Windows 中没有 overcommit，进程申请的内存总和不能超过物理内存+swap。</p><p>另外扯一下 WSL。由于 WSL 2 是虚拟机，而 Linux 内核又倾向于使用尽量多的内存，导致分配给 WSL 的内存会被吃满，空闲的内存（page cache 占据的部分）没法返还给 Windows。终于在 2023 年的某次更新中，WSL 引入了<a href=https://devblogs.microsoft.com/commandline/windows-subsystem-for-linux-september-2023-update/#automatic-memory-reclaim>autoReclaimMemory</a>，在 WSL 认为系统空闲后，会通过 cgroup 的 memory.reclaim 功能回收内存。</p><h2 id=小故事>小故事</h2><ul><li>在高速网络下，网络协议栈占用的内存可能会很可观。我同学碰到过在一个只有 500M 内存的机器上搭梯子，然后一跑测速梯子就会被 OOM Kill，最后排查出来是 tcp 的发送/接受缓存占用的内存太多。调了一下 <code>net.ipv4.tcp_wmem</code> 和 <code>net.ipv4.tcp_rmem</code> 就好了。</li></ul><h2 id=ref>ref</h2><ul><li>fc 老师的两篇关于 <a href=https://farseerfc.me/zhs/in-defence-of-swap.html>swap</a> 的<a href=https://farseerfc.me/zhs/followup-about-swap.html>文章</a>是我的内存管理启蒙</li></ul><hr width=100% id=EOF><p style=color:#777>最后修改于 2024-10-14</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2024/openwrt_transparent_proxy/>下回<br>OpenWrt 搭建透明代理
</a><a class=older-posts href=/posts/2024/japan_trip/>上回<br>日本之旅</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://blog.coherence.codes/><div class=nav-title>Coherence's Blog</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>存档
</a><a class="a-block nav-link-item false" href=/tags>标签
</a><a class="a-block nav-link-item false" href=/categories>分类
</a><a class="a-block nav-link-item false" href=/friends>友链
</a><a class="a-block nav-link-item false" href=/about>关于
</a><a class="a-block nav-link-item false" href=/index.xml>RSS Feed</a></div><div class=nav-footer><a href=https://github.com/cjc7373/hugo-theme-diary>Modified</a> Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</div></div><div id=extraContainer class=extra-container><div class=toc-wrapper><div class=toc><div class=toc-content><center>- 目录 -</center><ul><ul><li><a href=#%e4%bb%8e%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e5%bc%80%e5%a7%8b%e8%af%b4%e8%b5%b7 class=nav-从虚拟内存开始说起>从虚拟内存开始说起</a></li><li><a href=#page-cache class=nav-page-cache>Page Cache</a></li><li><a href=#vszrss class=nav-vszrss>VSZ/RSS</a></li><li><a href=#free class=nav-free>free</a></li><li><a href=#swap class=nav-swap>swap</a></li><li><a href=#windows class=nav-windows>Windows</a></li><li><a href=#%e5%b0%8f%e6%95%85%e4%ba%8b class=nav-小故事>小故事</a></li><li><a href=#ref class=nav-ref>ref</a></li></ul></div></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up
</i></a><a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div id=single-column-footer><a href=https://github.com/cjc7373/hugo-theme-diary>Modified</a> Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</div></div><script src=/js/journal.js></script></body></html>