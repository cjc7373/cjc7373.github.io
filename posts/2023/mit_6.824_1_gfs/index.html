<!doctype html><html><head><title>MIT 6.824 学习笔记(一) GFS</title>
<meta charset=utf-8><meta name=X-UA-Compatible content="IE=edge"><meta name=google-site-verification content="3MbbliKSwhNvv713tGB2RL8xvrJC404x1BFONabsw7g"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name=viewport><meta content="telephone=no" name=format-detection><meta name=description content><meta name=renderer content="webkit"><meta name=theme-color content="#ffffff"><script src=/js/toc.js></script><link type=text/css rel=stylesheet href=/vendor/css/bootstrap.min.css><link rel=stylesheet href=/scss/dark-mode.min.cb53f1bee2b8900cb4f082afbf00175d6618f281cf9a2fe8619e3b52d20b5721.css integrity="sha256-y1PxvuK4kAy08IKvvwAXXWYY8oHPmi/oYZ47UtILVyE=" media=screen><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Material+Icons"><script async defer data-domain=blog.coherence.codes src=https://analytics.coherence.space/js/plausible.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script></head><body><div id=app><div class=single-column-drawer-container id=drawer v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class=drawer-content><div class=drawer-menu><a class="a-block drawer-menu-item active" href=/posts>存档
</a><a class="a-block drawer-menu-item false" href=/tags>标签
</a><a class="a-block drawer-menu-item false" href=/categories>分类
</a><a class="a-block drawer-menu-item false" href=/friends>友链
</a><a class="a-block drawer-menu-item false" href=/about>关于
</a><a class="a-block drawer-menu-item false" href=/index.xml>RSS Feed</a><div class=toc><div class=toc-content><center>- 目录 -</center><ul><ul><li><a href=#%e6%9e%b6%e6%9e%84 class=nav-架构>架构</a></li><li><a href=#%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b class=nav-一致性模型>一致性模型</a></li><li><a href=#%e5%ae%9e%e7%8e%b0 class=nav-实现>实现</a></li><ul><li><a href=#%e5%86%99%e5%85%a5 class=nav-写入>写入</a></li><li><a href=#%e8%ae%b0%e5%bd%95%e8%bf%bd%e5%8a%a0record-append class=nav-记录追加record-append>记录追加（Record Append）</a></li></ul><li><a href=#%e9%97%ae%e9%a2%98 class=nav-问题>问题</a></li><li><a href=#%e6%80%bb%e7%bb%93 class=nav-总结>总结</a></li><li><a href=#%e5%8f%82%e8%80%83 class=nav-参考>参考</a></li></ul></div></div></div></div></div><transition name=fade><div id=drawer-mask v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if=isDrawerOpen v-on:click=toggleDrawer></div></transition><nav id=navBar class="navbar sticky-top navbar-light single-column-nav-container"><div id=navBackground class=nav-background></div><div class="container container-narrow nav-content"><button id=nav_dropdown_btn class=nav-dropdown-toggle type=button v-on:click=toggleDrawer>
<i class=material-icons>menu
</i></button>
<a id=navTitle class=navbar-brand href=https://blog.coherence.codes/>Coherence's Blog
</a><button type=button class=nav-darkmode-toggle id=darkModeToggleButton2>
<i class=material-icons id=darkModeToggleIcon2>dark_mode</i></button></div></nav><div class=single-column-header-container id=pageHead v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href=https://blog.coherence.codes/><div class=single-column-header-title>Coherence's Blog</div></a></div><div id=content><div id=streamContainer class=stream-container><div class="post-list-container post-list-container-shadow"><div class=post><div class=post-head-wrapper-text-only><div class=post-title>MIT 6.824 学习笔记(一) GFS<div class=post-meta><time itemprop=datePublished>2023-09-05 00:00
</time><i class=material-icons>folder</i>
<a href=/categories/>[Distributed System]</a>
&nbsp;</div></div></div><div class=post-body-wrapper><div class=post-body v-pre><p>存储系统通常是一个分布式系统的基石，通常应用可以是无状态的，而所有状态便由存储系统来管理。</p><p>Google 文件系统（The Google File System, GFS）在 2003 年于一篇同名论文中被提出，发表在系统领域顶会 SOSP 上，是 Google 大数据三驾马车之一<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。GFS 是一个成功的系统，在 00 年代早期，人们对于分布式文件系统已经有很好的理解了，但是尚未有一个可以扩展到上千个节点的系统被实现出来。很多 GFS 的设计被 HDFS 等后来的分布式文件系统上。</p><p>GFS 基于以下几个方面的观察：</p><ul><li>节点故障是常见的，因为其运行在大量普通机器（commodity components）上</li><li>存储的文件以大文件（数百 MB 到数 GB）为主，小文件应当被支持，但不应对其优化</li><li>对文件的大多数写入操作是追加 （append）而不是覆盖/随机写，大多数读取操作是顺序读 （1 MB 或更多）<ul><li>所以系统必须有良好的并发追加操作的语义</li><li>工作负载通常是批处理任务，所以高吞吐量比低延时重要</li></ul></li><li>同时设计应用和文件系统 API 有利于整个系统的灵活性</li></ul><h2 id=架构>架构</h2><p><img src=./image-20230901145431686.png alt=image-20230901145431686></p><p>GFS 采用 Master/Slave 架构，集群中存在一个 master 和多个 chunkservers，并且被多个 clients 访问。（由于单 master 的存在，GFS 存在单点故障的可能性，虽然 master 同样有备份，但恢复可能需要人工干预）一个文件将被分割成多个 chunk。chunk 的特性如下：</p><ul><li>固定大小，Google 的选择是 64 MB，这么大的 chunk 将有如下好处：<ul><li>减少 client 和 master 的通信，因为在获取到 chunk 的信息后，client 只需要和 chunkserver 交互进行读写</li><li>减少 metadata 的尺寸，以便所有 metadata 可以保存在内存中</li></ul></li><li>作为一个普通的 Linux 文件存储在 chunkserver 上</li><li>每个 chunk 由一个不可变的、唯一的 64 位 chunk handle 标记，其由 master 在 chunk 创建时指定<ul><li>chunkserver 根据 chunk handle 和偏移（byte range）来读写 chunk</li></ul></li><li>为了可靠性，每个 chunk 会被复制到多个 chunkservers 上 （通常为三个）</li></ul><p>master 管理了所有的元数据，用 Go 代码大概表示为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ChunkHandle</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Handle</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ChunkServers</span> []<span style=color:#a6e22e>ChuckServer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ReplicaNum</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Version</span> <span style=color:#66d9ef>int</span> <span style=color:#75715e>// 为了区分数据是否是最新的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Primary</span> <span style=color:#a6e22e>ChuckServer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LeaseExpiration</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Master</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Files</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>Filename</span>][]<span style=color:#a6e22e>ChunkHandle</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>除此之外，还需要 log 和 checkpoint 机制来持久化元数据。元数据中 Handle, ReplicaNum 和 Version 应该是非易失的（non-volatile)。没有持久化 ChunkServers 字段可能是因为 chunkserver 会经常变动。</p><h2 id=一致性模型>一致性模型</h2><p>GFS 采用了一种宽松的一致性模型，不同于 Raft 等强一致性协议，其允许不一致的情况出现。不一致的情况将由应用处理。这实际上是为了性能而牺牲了一些一致性。</p><p><img src=./image-20230901182949527.png alt=image-20230901182949527></p><p>对于一个文件区域，GFS 定义了几种状态：</p><ul><li>一致的（consistent）：无论从哪个 replica 读，所有 clients 都会看到同样的数据</li><li>确定的（defined）：在一次写入之后，数据是一致的，并且 clients 都能完整看到这次写入写了什么。</li><li>不一致的（inconsistent）：不同的 client 能够读到不一样的结果</li></ul><p>这三种状态发生于以下情况：</p><ul><li>当没有并发写的写入成功后，这块区域就是确定的</li><li>当若干写入操作并发成功后，这块文件区域是不确定但一致的：所有 clients 都能看到同样的数据，但这块可能不能反映出其中任何一次写入的结果（通常是这几次写入的结果交织在一起）</li><li>失败的写入使得这块区域不一致</li></ul><p>GFS 中的写入（mutation）分为指定偏移量的写入（Write）和记录末尾追加（Record Append），record append 能够保证原子的至少一次（at least once）追加，但是有小概率会出现 padding 或者重复数据。GFS 的应用可以通过在每条记录后加入校验来处理不完整的记录，还可以通过加入唯一的标识符来处理重复记录。GFS 的客户端库中包含了这些通用的处理不一致的功能。</p><h2 id=实现>实现</h2><p>GFS 使用租约（lease）来维护一个一致的写入顺序（consistent mutation order）。租约就是在一段时间内，master 让某一 replica 成为 primary，master 将保证在这段时间内不会分配另一个 primary，而 primary 将保证在租约过期后不再履行 primary 的职责。primary 将指定一个 chunk 的写入顺序，其他的 replica 则跟随 primary 的顺序。</p><h3 id=写入>写入</h3><p><img src=./image-20230905110612114.png alt=image-20230905110612114></p><p>client 首先向 master 请求 primary 和其他 replicas 的位置。如果尚未有一个 primary，master 会首先增大版本号并通知所有 replicas，然后选定一个 primary 并向其分配租约。client 会缓存这些元数据，以减少 master 的负载。</p><p>client 随后向所有 replica 推送数据，数据被存储在 chunkserver 的本地缓存中等待被使用。数据流和控制流是分离的，这是为了更有效地利用网络。数据流采用了一种流水线的形式，首先 client 向距离其最近的 chunkserver 推送数据，这个 chunkserver 再向其最近的 chunkserver 转发，链式地发送数据，转发不会等待 chunk 传输完而是立即开始的。</p><p>当所有 repicas 都 ACK 收到了数据之后，client 向 primary 请求写入。由于可能存在并发，primary 为所有写入分配一个序列号，在本地应用这些写入，并转发写入请求到其他 replicas。所有 replicas 都 ACK 之后，primary 向 client 回复。如果任何一个 replica 出错，那么被修改的区域就处于不一致的状态，此时由 client 来负责重试失败的写入。（如果在 primary 就出错的话，那么它不会转发写入请求，此时数据应该仍然处于一致的状态）</p><p>当应用写入的区域很大时，GFS client 会将其切分成一个一个 chunk，并分为多个写入操作来执行，此时如果有并发操作，则会出现一致但不确定的状态。</p><h3 id=记录追加record-append>记录追加（Record Append）</h3><p>此操作中 client 只指定文件而不指定偏移，GFS 保证该操作在 GFS 指定的偏移处原子地完成至少一次，并向客户端返回这个偏移。GFS 的应用中有很多是多生产者/单消费者模型，很适合使用记录追加操作。</p><p>记录追加操作和写入大致相同，惟 primary 会检查要追加的数据是否会超出当前 chunk，如果会的话，它将 pad 这个 chunk 到 64MB，指示其他 replicas 也这么操作，并指示客户端重试。（记录追加操作限制最大数据大小为四分之一个最大 chunk size 以便控制碎片的大小）如果没有超出，则按写入的流程进行，此时 primary 会选择一个 offset （即它所认为的文件末尾）告知其他 replicas 进行写入。如果任何一个 replica 失败，客户端会重试操作。这种情况下部分 replica 将会出现重复的记录，但是数据肯定以某一偏移写入了所有 replicas。</p><h2 id=问题>问题</h2><ul><li>如果 chunk 的版本号只在分配租约是增加的话，假设一个 replica （非 primary）在某一时刻挂了，因此错过了几个写入，如果版本号此时不改变的话，在那个 replica 恢复之后，client 就会读到过时数据了。论文里好像也没提这种情况怎么处理..</li></ul><h2 id=总结>总结</h2><p>以上并未包含论文的完整内容。GFS 我早在去年夏天就开始学了，然后就一直搁置在一旁，直到这两天才重新拿起来&mldr;</p><h2 id=参考>参考</h2><p>本文的内容来源于：</p><ul><li>GFS 论文</li><li><a href="https://www.youtube.com/watch?v=EpIgvowZr00&amp;t=1935s">6.824 Lecture 3: GFS</a></li><li><a href=https://mr-dai.github.io/gfs/>Google File System 总结</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>另外两篇论文是 MapReduce: Simplified Data Processing on Large Clusters 和 Bigtable: A Distributed Storage System for Structured Data&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><hr width=100% id=EOF><p style=color:#777>最后修改于 2023-09-05</p></div></div><nav class=post-pagination><a class=newer-posts href=/posts/2023/git_%E5%85%A5%E9%97%A8/>下回<br>git 入门
</a><a class=older-posts href=/posts/2023/%E7%A5%9E%E7%A7%98%E7%9A%84%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/>上回<br>神秘的自动关闭显示器失效问题</a></nav><div class=post-comment-wrapper></div></div></div></div></div><div id=sideContainer class=side-container><a class="a-block nav-head false" href=https://blog.coherence.codes/><div class=nav-title>Coherence's Blog</div></a><div class=nav-link-list><a class="a-block nav-link-item active" href=/posts>存档
</a><a class="a-block nav-link-item false" href=/tags>标签
</a><a class="a-block nav-link-item false" href=/categories>分类
</a><a class="a-block nav-link-item false" href=/friends>友链
</a><a class="a-block nav-link-item false" href=/about>关于
</a><a class="a-block nav-link-item false" href=/index.xml>RSS Feed</a></div><div class=nav-footer><a href=https://github.com/cjc7373/hugo-theme-diary>Modified</a> Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</div></div><div id=extraContainer class=extra-container><div class=toc-wrapper><div class=toc><div class=toc-content><center>- 目录 -</center><ul><ul><li><a href=#%e6%9e%b6%e6%9e%84 class=nav-架构>架构</a></li><li><a href=#%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b class=nav-一致性模型>一致性模型</a></li><li><a href=#%e5%ae%9e%e7%8e%b0 class=nav-实现>实现</a></li><ul><li><a href=#%e5%86%99%e5%85%a5 class=nav-写入>写入</a></li><li><a href=#%e8%ae%b0%e5%bd%95%e8%bf%bd%e5%8a%a0record-append class=nav-记录追加record-append>记录追加（Record Append）</a></li></ul><li><a href=#%e9%97%ae%e9%a2%98 class=nav-问题>问题</a></li><li><a href=#%e6%80%bb%e7%bb%93 class=nav-总结>总结</a></li><li><a href=#%e5%8f%82%e8%80%83 class=nav-参考>参考</a></li></ul></div></div></div><div class=pagination><a id=globalBackToTop class="pagination-action animated-visibility" href=#top :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up
</i></a><a type=button class=pagination-action id=darkModeToggleButton><span class="material-icons pagination-action-icon" id=darkModeToggleIcon>dark_mode</span></a></div></div><div id=single-column-footer><a href=https://github.com/cjc7373/hugo-theme-diary>Modified</a> Hugo Theme <a href=https://github.com/amazingrise/hugo-theme-diary>Diary</a> by <a href=https://risehere.net/>Rise</a><br>移植自 <a href=https://mak1t0.cc/ target=_blank rel="noreferrer noopener">Makito</a>'s <a href=https://github.com/SumiMakito/hexo-theme-journal/ target=_blank rel="noreferrer noopener">Journal.</a><br><br>&copy;
Coherence. 本站遵循 CC BY-NC-SA 4.0 协议</div></div><script src=/js/journal.js></script></body></html>